---
description: Rules for prohibiting string literals and enforcing strict type safety with constants, enums, and typed constructs in Next.js applications. Apply when creating type-safe code and preventing implicit string values in the codebase.
globs:
alwaysApply: false
---

# Next.js String Literal Prohibition and Type Safety Rules

This rule set complements @3-nextjs-type-system.mdc, focusing specifically on enforcing strict type safety by preventing string literals usage throughout the codebase.

## 1. String Literal Restrictions (P0)

1. CRITICAL: Use enums instead of string literals:
   ```tsx
   // PROHIBITED: String literals in code
   function getUserRole(role: string) {
     switch (role) {
       case "admin":
         return { canEdit: true, canDelete: true };
       case "editor":
         return { canEdit: true, canDelete: false };
       case "viewer":
         return { canEdit: false, canDelete: false };
       default:
         return { canEdit: false, canDelete: false };
     }
   }
   
   // REQUIRED: Use enums with TypeScript
   enum UserRole {
     ADMIN = "admin",
     EDITOR = "editor",
     VIEWER = "viewer"
   }
   
   function getUserRole(role: UserRole) {
     switch (role) {
       case UserRole.ADMIN:
         return { canEdit: true, canDelete: true };
       case UserRole.EDITOR:
         return { canEdit: true, canDelete: false };
       case UserRole.VIEWER:
         return { canEdit: false, canDelete: false };
       default:
         return { canEdit: false, canDelete: false };
     }
   }
   ```

2. REQUIRED: Use constants for string values:
   ```tsx
   // PROHIBITED: Repeated string literals
   fetch("/api/users?status=active")
   fetch("/api/users?status=inactive")
   
   // REQUIRED: Define constants
   const API_ENDPOINTS = {
     USERS: {
       ACTIVE: "/api/users?status=active",
       INACTIVE: "/api/users?status=inactive"
     }
   } as const;
   
   fetch(API_ENDPOINTS.USERS.ACTIVE)
   fetch(API_ENDPOINTS.USERS.INACTIVE)
   ```

3. ESSENTIAL: Define ESLint rules for detection:
   ```json
   // .eslintrc.json
   {
     "rules": {
       "no-string-literals": "error",
       "@typescript-eslint/no-magic-numbers": ["error", { "ignore": [0, 1, -1] }],
       "@typescript-eslint/prefer-enum-initializers": "error"
     }
   }
   ```

## 2. Constant Collection Patterns (P0)

1. CRITICAL: Use type-safe constant objects:
   ```tsx
   // PROHIBITED: Untyped constant objects
   const COLORS = {
     PRIMARY: "#0070f3",
     SECONDARY: "#1a202c",
     ERROR: "#ff0000"
   };
   
   // REQUIRED: Typed constants with 'as const' assertion
   const COLORS = {
     PRIMARY: "#0070f3",
     SECONDARY: "#1a202c",
     ERROR: "#ff0000"
   } as const;
   
   // Create a type from the constant
   type ColorKey = keyof typeof COLORS;
   type ColorValue = typeof COLORS[ColorKey];
   ```

2. REQUIRED: Create type-safe lookup operations:
   ```tsx
   // Pattern for type-safe lookup with TS
   const STATUS_CODE = {
     OK: 200,
     CREATED: 201,
     BAD_REQUEST: 400,
     NOT_FOUND: 404,
     SERVER_ERROR: 500
   } as const;
   
   type StatusCodeKey = keyof typeof STATUS_CODE;
   type StatusCodeValue = typeof STATUS_CODE[StatusCodeKey];
   
   function getStatusMessage(code: StatusCodeValue): string {
     const messages: Record<StatusCodeValue, string> = {
       200: "Success",
       201: "Created",
       400: "Bad Request",
       404: "Not Found",
       500: "Server Error"
     };
     
     return messages[code];
   }
   ```

3. ESSENTIAL: Document patterns in shared libraries:
   ```tsx
   // lib/constants.ts
   export function createConstantLookup<T extends Record<string, unknown>>(constants: T & { [K in keyof T]: T[K] }) {
     // Return both the constants and TypeScript types
     return {
       values: constants,
       // Type helpers are generated but not included in runtime
       _types: null as unknown as {
         keys: keyof typeof constants,
         values: typeof constants[keyof typeof constants]
       }
     };
   }
   
   // Usage
   export const THEMES = createConstantLookup({
     LIGHT: "light",
     DARK: "dark",
     SYSTEM: "system"
   });
   
   // Type-safe usage
   type ThemeKey = typeof THEMES._types.keys; // "LIGHT" | "DARK" | "SYSTEM"
   type ThemeValue = typeof THEMES._types.values; // "light" | "dark" | "system"
   
   // Runtime usage
   const theme: ThemeValue = THEMES.values.DARK;
   ```

## 3. Event Handling and Actions (P1)

1. CRITICAL: Define event name constants for components:
   ```tsx
   // PROHIBITED: String literal event names
   element.addEventListener("click", handleClick);
   document.dispatchEvent(new CustomEvent("user-login"));
   
   // REQUIRED: Event name constants
   const EVENTS = {
     CLICK: "click",
     USER_LOGIN: "user-login"
   } as const;
   
   element.addEventListener(EVENTS.CLICK, handleClick);
   document.dispatchEvent(new CustomEvent(EVENTS.USER_LOGIN));
   ```

2. REQUIRED: Type-safe Redux action types:
   ```tsx
   // PROHIBITED: String literal action types
   dispatch({ type: "ADD_TODO", payload: todo });
   
   // REQUIRED: Constant action types
   const ACTION_TYPES = {
     ADD_TODO: "todo/add",
     TOGGLE_TODO: "todo/toggle",
     DELETE_TODO: "todo/delete"
   } as const;
   
   type ActionType = typeof ACTION_TYPES[keyof typeof ACTION_TYPES];
   
   // Action creators
   const addTodo = (todo: Todo) => ({
     type: ACTION_TYPES.ADD_TODO,
     payload: todo
   });
   
   // Type-safe dispatch
   dispatch(addTodo(newTodo));
   ```

3. ESSENTIAL: Custom event types:
   ```tsx
   // Define type-safe custom events
   const CUSTOM_EVENTS = {
     USER_PREFERENCE_CHANGE: "user-preference-change",
     DATA_REFRESH: "data-refresh"
   } as const;
   
   type CustomEventName = typeof CUSTOM_EVENTS[keyof typeof CUSTOM_EVENTS];
   
   // Type-safe event payload interfaces
   interface UserPreferenceChangeEvent {
     detail: {
       theme: typeof THEMES._types.values;
       notifications: boolean;
     }
   }
   
   interface EventMap {
     [CUSTOM_EVENTS.USER_PREFERENCE_CHANGE]: UserPreferenceChangeEvent;
     [CUSTOM_EVENTS.DATA_REFRESH]: CustomEvent;
   }
   
   // Type-safe event emitter
   function emitEvent<E extends CustomEventName>(
     eventName: E,
     detail: EventMap[E]["detail"]
   ) {
     const event = new CustomEvent(eventName, { detail });
     document.dispatchEvent(event);
   }
   ```

## 4. Error and Status Codes (P1)

1. CRITICAL: Use constants for error codes:
   ```tsx
   // PROHIBITED: String literal error codes
   throw new Error("INVALID_USER_INPUT");
   
   // REQUIRED: Error code constants
   const ERROR_CODES = {
     INVALID_USER_INPUT: "INVALID_USER_INPUT",
     NETWORK_FAILURE: "NETWORK_FAILURE",
     AUTHENTICATION_FAILED: "AUTHENTICATION_FAILED",
     PERMISSION_DENIED: "PERMISSION_DENIED"
   } as const;
   
   type ErrorCode = typeof ERROR_CODES[keyof typeof ERROR_CODES];
   
   // Type-safe error class
   class AppError extends Error {
     code: ErrorCode;
     
     constructor(code: ErrorCode, message?: string) {
       super(message || code);
       this.code = code;
     }
   }
   
   throw new AppError(ERROR_CODES.INVALID_USER_INPUT);
   ```

2. REQUIRED: HTTP status code constants:
   ```tsx
   // PROHIBITED: Numeric status code literals
   if (response.status === 404) {
     // Handle not found
   }
   
   // REQUIRED: HTTP status constants
   const HTTP_STATUS = {
     OK: 200,
     CREATED: 201,
     BAD_REQUEST: 400,
     UNAUTHORIZED: 401,
     FORBIDDEN: 403,
     NOT_FOUND: 404,
     SERVER_ERROR: 500
   } as const;
   
   type HttpStatus = typeof HTTP_STATUS[keyof typeof HTTP_STATUS];
   
   if (response.status === HTTP_STATUS.NOT_FOUND) {
     // Handle not found
   }
   ```

3. ESSENTIAL: Use enums for error categories:
   ```tsx
   // Define error categories
   enum ErrorCategory {
     VALIDATION = "validation",
     NETWORK = "network",
     AUTHENTICATION = "authentication",
     AUTHORIZATION = "authorization",
     SERVER = "server"
   }
   
   // Error type with categorization
   interface AppErrorData {
     code: ErrorCode;
     category: ErrorCategory;
     details?: Record<string, unknown>;
   }
   
   // Map error codes to categories
   const ERROR_MAP: Record<ErrorCode, ErrorCategory> = {
     [ERROR_CODES.INVALID_USER_INPUT]: ErrorCategory.VALIDATION,
     [ERROR_CODES.NETWORK_FAILURE]: ErrorCategory.NETWORK,
     [ERROR_CODES.AUTHENTICATION_FAILED]: ErrorCategory.AUTHENTICATION,
     [ERROR_CODES.PERMISSION_DENIED]: ErrorCategory.AUTHORIZATION
   };
   ```

## 5. Component Props and UI States (P1)

1. CRITICAL: Define component variant types:
   ```tsx
   // PROHIBITED: String literal variants
   <Button variant="primary" size="large" />
   
   // REQUIRED: Type-safe variants
   const BUTTON_VARIANT = {
     PRIMARY: "primary",
     SECONDARY: "secondary",
     OUTLINE: "outline",
     GHOST: "ghost"
   } as const;
   
   const BUTTON_SIZE = {
     SMALL: "small",
     MEDIUM: "medium",
     LARGE: "large"
   } as const;
   
   type ButtonVariant = typeof BUTTON_VARIANT[keyof typeof BUTTON_VARIANT];
   type ButtonSize = typeof BUTTON_SIZE[keyof typeof BUTTON_SIZE];
   
   interface ButtonProps {
     variant: ButtonVariant;
     size: ButtonSize;
     // other props
   }
   
   <Button variant={BUTTON_VARIANT.PRIMARY} size={BUTTON_SIZE.LARGE} />
   ```

2. REQUIRED: Typed UI states:
   ```tsx
   // PROHIBITED: String literal states
   const [status, setStatus] = useState("loading");
   
   // REQUIRED: Use discriminated unions with constants
   const UI_STATE = {
     IDLE: "idle",
     LOADING: "loading",
     SUCCESS: "success",
     ERROR: "error"
   } as const;
   
   type UIState = typeof UI_STATE[keyof typeof UI_STATE];
   
   // Type-safe data loading state
   type DataState<T, E = Error> =
     | { status: typeof UI_STATE.IDLE }
     | { status: typeof UI_STATE.LOADING }
     | { status: typeof UI_STATE.SUCCESS; data: T }
     | { status: typeof UI_STATE.ERROR; error: E };
   
   const [state, setState] = useState<DataState<User>>({ status: UI_STATE.IDLE });
   
   // Type-safe state transitions
   setState({ status: UI_STATE.LOADING });
   ```

3. RECOMMENDED: Form field types:
   ```tsx
   // Define form field types
   const FIELD_TYPE = {
     TEXT: "text",
     EMAIL: "email",
     PASSWORD: "password",
     NUMBER: "number",
     DATE: "date",
     SELECT: "select",
     CHECKBOX: "checkbox",
     RADIO: "radio"
   } as const;
   
   type FieldType = typeof FIELD_TYPE[keyof typeof FIELD_TYPE];
   
   interface Field {
     name: string;
     type: FieldType;
     label: string;
     required?: boolean;
     options?: Array<{
       label: string;
       value: string | number;
     }>;
   }
   
   // Form fields configuration
   const userFormFields: Field[] = [
     {
       name: "username",
       type: FIELD_TYPE.TEXT,
       label: "Username",
       required: true
     },
     {
       name: "email",
       type: FIELD_TYPE.EMAIL,
       label: "Email Address",
       required: true
     }
   ];
   ```

## 6. API Parameters and Responses (P2)

1. REQUIRED: Use constants for API parameters:
   ```tsx
   // PROHIBITED: String literals in API calls
   fetch("/api/users?sortBy=name&order=asc");
   
   // REQUIRED: Defined constants
   const SORT_FIELD = {
     NAME: "name",
     CREATED_AT: "createdAt",
     UPDATED_AT: "updatedAt"
   } as const;
   
   const SORT_ORDER = {
     ASC: "asc",
     DESC: "desc"
   } as const;
   
   type SortField = typeof SORT_FIELD[keyof typeof SORT_FIELD];
   type SortOrder = typeof SORT_ORDER[keyof typeof SORT_ORDER];
   
   interface QueryParams {
     sortBy: SortField;
     order: SortOrder;
   }
   
   // Type-safe parameter generation
   function buildQueryString(params: QueryParams): string {
     return Object.entries(params)
       .map(([key, value]) => `${key}=${value}`)
       .join("&");
   }
   
   const queryParams: QueryParams = {
     sortBy: SORT_FIELD.NAME,
     order: SORT_ORDER.ASC
   };
   
   fetch(`/api/users?${buildQueryString(queryParams)}`);
   ```

2. ESSENTIAL: Use type-safe response handling:
   ```tsx
   // Define API response status
   const API_STATUS = {
     SUCCESS: "success",
     ERROR: "error"
   } as const;
   
   type ApiStatus = typeof API_STATUS[keyof typeof API_STATUS];
   
   // Type-safe API response
   interface ApiResponse<T> {
     status: ApiStatus;
     data?: T;
     error?: {
       code: ErrorCode;
       message: string;
     };
   }
   
   // Example usage
   async function fetchUsers(): Promise<ApiResponse<User[]>> {
     try {
       const response = await fetch("/api/users");
       const users: User[] = await response.json();
       return {
         status: API_STATUS.SUCCESS,
         data: users
       };
     } catch (error) {
       return {
         status: API_STATUS.ERROR,
         error: {
           code: ERROR_CODES.NETWORK_FAILURE,
           message: "Failed to fetch users"
         }
       };
     }
   }
   
   // Type-safe handling
   const result = await fetchUsers();
   if (result.status === API_STATUS.SUCCESS && result.data) {
     // Handle success
   } else if (result.error?.code === ERROR_CODES.NETWORK_FAILURE) {
     // Handle specific error
   }
   ```

## 7. Environment Variables (P2)

1. REQUIRED: Type-safe environment variables:
   ```tsx
   // PROHIBITED: Direct env variable access
   const apiUrl = process.env.NEXT_PUBLIC_API_URL;
   
   // REQUIRED: Define constants with strong typing
   const ENV_VAR = {
     API_URL: "NEXT_PUBLIC_API_URL",
     AUTH_URL: "NEXT_PUBLIC_AUTH_URL",
     API_KEY: "API_KEY",
     NODE_ENV: "NODE_ENV"
   } as const;
   
   type EnvVar = typeof ENV_VAR[keyof typeof ENV_VAR];
   
   // Type-safe environment accessor
   function getEnv(key: EnvVar): string {
     const value = process.env[key];
     if (value === undefined) {
       throw new Error(`Environment variable ${key} is not defined`);
     }
     return value;
   }
   
   // Usage
   const apiUrl = getEnv(ENV_VAR.API_URL);
   ```

2. RECOMMENDED: Environment configuration object:
   ```tsx
   // Create a strongly typed config object
   interface AppConfig {
     api: {
       url: string;
       timeout: number;
     };
     auth: {
       url: string;
       clientId: string;
     };
     features: {
       darkMode: boolean;
       analytics: boolean;
     };
   }
   
   // Load config from environment
   function loadConfig(): AppConfig {
     return {
       api: {
         url: getEnv(ENV_VAR.API_URL),
         timeout: 5000
       },
       auth: {
         url: getEnv(ENV_VAR.AUTH_URL),
         clientId: "your-client-id"
       },
       features: {
         darkMode: true,
         analytics: process.env.NODE_ENV === "production"
       }
     };
   }
   
   // Export config as a singleton
   export const config = loadConfig();
   
   // Type-safe usage
   fetch(`${config.api.url}/users`);
   ```

## 8. Migration Strategies (P3)

1. ESSENTIAL: Gradual replacement strategy:
   ```tsx
   // Step 1: Identify string literals to replace
   // Use a utility like ts-morph or grep to find all string literals
   
   // Step 2: Create centralized constants
   // constants/index.ts
   export const ROUTES = {
     HOME: "/",
     DASHBOARD: "/dashboard",
     PROFILE: "/profile",
     SETTINGS: "/settings"
   } as const;
   
   // Step 3: Replace with imports
   // Before
   router.push("/dashboard");
   
   // After
   import { ROUTES } from "@/constants";
   router.push(ROUTES.DASHBOARD);
   ```

2. RECOMMENDED: ESLint plugin to detect string literals:
   ```json
   // .eslintrc.json
   {
     "plugins": ["@typescript-eslint", "no-literal-strings"],
     "rules": {
       "no-literal-strings/no-literal-strings": ["error", {
         "allowedStrings": ["", " "],
         "ignoreProps": false,
         "ignoreTemplateLiterals": true
       }]
     }
   }
   ```

3. RECOMMENDED: Type-safe migration plan:
   - Document all occurrences of string literals
   - Prioritize by frequency and importance
   - Create types and constants for each category
   - Implement changes incrementally, starting with core components
   - Add automated tests to verify type safety
   - Update documentation with new patterns
   - Create review process for new code

For additional guidance on TypeScript type system implementation, see @3-nextjs-type-system.mdc.
