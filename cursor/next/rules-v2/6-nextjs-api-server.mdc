---
description: Guidelines for implementing server-side API routes and data handling in Next.js applications.
globs:
alwaysApply: false
---

# Next.js Server API Guidelines

## 1. Route Handlers (P0)

1. CRITICAL: Basic structure:
   ```typescript
   // app/api/[resource]/route.ts
   import { NextResponse } from "next/server"
   import { z } from "zod"
   
   const ResourceSchema = z.object({
     // Define your schema
   })
   
   export async function GET(
     request: Request,
     { params }: { params: { resource: string } }
   ) {
     try {
       // Handle GET request
       return NextResponse.json({ data: null, error: null })
     } catch (error) {
       return NextResponse.json(
         { 
           data: null, 
           error: { code: "INTERNAL_ERROR", message: String(error) }
         },
         { status: 500 }
       )
     }
   }
   
   export async function POST(request: Request) {
     try {
       const body = await request.json()
       const result = ResourceSchema.safeParse(body)
       
       if (!result.success) {
         return NextResponse.json(
           { data: null, error: { code: "VALIDATION_ERROR", message: "Invalid data" }},
           { status: 400 }
         )
       }
       
       // Handle POST request
       return NextResponse.json({ data: null, error: null }, { status: 201 })
     } catch (error) {
       return NextResponse.json(
         { data: null, error: { code: "INTERNAL_ERROR", message: String(error) }},
         { status: 500 }
       )
     }
   }
   ```

2. REQUIRED: Error handling:
   ```typescript
   // lib/errors.ts
   export class AppError extends Error {
     constructor(
       public code: string,
       message: string,
       public details?: Record<string, unknown>
     ) {
       super(message)
       this.name = "AppError"
     }
   }
   
   export function handleApiError(error: unknown) {
     if (error instanceof AppError) {
       return {
         data: null,
         error: {
           code: error.code,
           message: error.message,
           details: error.details,
         },
       }
     }
     
     console.error(error)
     return {
       data: null,
       error: {
         code: "INTERNAL_ERROR",
         message: error instanceof Error ? error.message : "Unknown error",
       },
     }
   }
   ```

## 2. Server Actions (P0)

1. CRITICAL: Form actions:
   ```typescript
   // lib/actions.ts
   "use server"
   
   import { revalidatePath } from "next/cache"
   import { z } from "zod"
   
   const UserSchema = z.object({
     name: z.string().min(2),
     email: z.string().email(),
   })
   
   export async function createUser(formData: FormData) {
     const result = UserSchema.safeParse({
       name: formData.get("name"),
       email: formData.get("email"),
     })
     
     if (!result.success) {
       return { error: result.error.format(), data: null }
     }
     
     try {
       // Handle user creation
       revalidatePath("/users")
       return { data: null, error: null }
     } catch (error) {
       return { error: { message: String(error) }, data: null }
     }
   }
   ```

2. REQUIRED: Usage with forms:
   ```typescript
   // app/users/create/page.tsx
   import { createUser } from "@/lib/actions"
   
   export default function CreateUserPage() {
     return (
       <form action={createUser}>
         <input type="text" name="name" required minLength={2} />
         <input type="email" name="email" required />
         <button type="submit">Create User</button>
       </form>
     )
   }
   ```

## 3. Middleware (P1)

1. CRITICAL: Authentication:
   ```typescript
   // middleware.ts
   import { NextResponse } from "next/server"
   import type { NextRequest } from "next/server"
   
   export function middleware(request: NextRequest) {
     const token = request.cookies.get("token")
     
     if (!token && request.nextUrl.pathname.startsWith("/api")) {
       return NextResponse.json(
         { error: { code: "UNAUTHORIZED", message: "Missing token" }},
         { status: 401 }
       )
     }
     
     return NextResponse.next()
   }
   
   export const config = {
     matcher: ["/api/:path*"],
   }
   ```

2. REQUIRED: Rate limiting:
   ```typescript
   // lib/rate-limit.ts
   import { NextResponse } from "next/server"
   import { Redis } from "@upstash/redis"
   
   const redis = new Redis({
     url: process.env.REDIS_URL!,
     token: process.env.REDIS_TOKEN!,
   })
   
   export async function rateLimit(ip: string, limit = 10, window = 60) {
     const key = `rate-limit:${ip}`
     const count = await redis.incr(key)
     
     if (count === 1) {
       await redis.expire(key, window)
     }
     
     if (count > limit) {
       return NextResponse.json(
         { error: { code: "RATE_LIMITED", message: "Too many requests" }},
         { status: 429 }
       )
     }
     
     return null
   }
   ```

## 4. Database Integration (P1)

1. CRITICAL: Connection handling:
   ```typescript
   // lib/db.ts
   import { PrismaClient } from "@prisma/client"
   
   const globalForPrisma = globalThis as unknown as {
     prisma: PrismaClient | undefined
   }
   
   export const prisma =
     globalForPrisma.prisma ??
     new PrismaClient({
       log: process.env.NODE_ENV === "development" ? ["query", "error"] : ["error"],
     })
   
   if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma
   ```

2. REQUIRED: Repository pattern:
   ```typescript
   // lib/repositories/user.ts
   import { prisma } from "@/lib/db"
   
   export class UserRepository {
     async findMany(options = {}) {
       return prisma.user.findMany(options)
     }
     
     async create(data: unknown) {
       return prisma.user.create({ data })
     }
     
     async update(id: string, data: unknown) {
       return prisma.user.update({ where: { id }, data })
     }
     
     async delete(id: string) {
       return prisma.user.delete({ where: { id } })
     }
   }
   ``` 