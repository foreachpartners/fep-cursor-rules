---
description: Guidelines for implementing server-side API routes and data handling in Next.js applications. Apply when building API endpoints, server actions, and database integrations.
globs:
alwaysApply: false
---

# Next.js Server API Guidelines

## 1. Purpose (P0)

These guidelines ensure consistent and type-safe implementation of server-side API features in Next.js applications. Apply when creating API routes, implementing server actions, or setting up database integrations.

## 2. Route Handlers (P0)

1. CRITICAL: Basic structure:
   ```typescript
   // app/api/[resource]/route.ts
   import { NextResponse } from "next/server"
   import { z } from "zod"
   
   const ResourceSchema = z.object({
     // Define your schema
   })
   
   export async function GET(
     request: Request,
     { params }: { params: { resource: string } }
   ) {
     try {
       // Handle GET request
       return NextResponse.json({ data: null, error: null })
     } catch (error) {
       return NextResponse.json(
         { 
           data: null, 
           error: { code: "INTERNAL_ERROR", message: String(error) }
         },
         { status: 500 }
       )
     }
   }
   
   export async function POST(request: Request) {
     try {
       const body = await request.json()
       const result = ResourceSchema.safeParse(body)
       
       if (!result.success) {
         return NextResponse.json(
           { data: null, error: { code: "VALIDATION_ERROR", message: "Invalid data" }},
           { status: 400 }
         )
       }
       
       // Handle POST request
       return NextResponse.json({ data: null, error: null }, { status: 201 })
     } catch (error) {
       return NextResponse.json(
         { data: null, error: { code: "INTERNAL_ERROR", message: String(error) }},
         { status: 500 }
       )
     }
   }
   ```

2. REQUIRED: Error handling:
   ```typescript
   // lib/errors.ts
   export class AppError extends Error {
     constructor(
       public code: string,
       message: string,
       public details?: Record<string, unknown>
     ) {
       super(message)
       this.name = "AppError"
     }
   }
   
   export function handleApiError(error: unknown) {
     if (error instanceof AppError) {
       return {
         data: null,
         error: {
           code: error.code,
           message: error.message,
           details: error.details,
         },
       }
     }
     
     console.error(error)
     return {
       data: null,
       error: {
         code: "INTERNAL_ERROR",
         message: error instanceof Error ? error.message : "Unknown error",
       },
     }
   }
   ```

## 3. Server Actions (P0)

1. CRITICAL: Form actions:
   ```typescript
   // lib/actions.ts
   "use server"
   
   import { revalidatePath } from "next/cache"
   import { z } from "zod"
   
   const UserSchema = z.object({
     name: z.string().min(2),
     email: z.string().email(),
   })
   
   export async function createUser(formData: FormData) {
     const result = UserSchema.safeParse({
       name: formData.get("name"),
       email: formData.get("email"),
     })
     
     if (!result.success) {
       return { error: result.error.format(), data: null }
     }
     
     try {
       // Handle user creation
       revalidatePath("/users")
       return { data: null, error: null }
     } catch (error) {
       return { error: { message: String(error) }, data: null }
     }
   }
   ```

2. REQUIRED: Usage with forms:
   ```typescript
   // app/users/create/page.tsx
   import { createUser } from "@/lib/actions"
   
   export default function CreateUserPage() {
     return (
       <form action={createUser}>
         <input type="text" name="name" required minLength={2} />
         <input type="email" name="email" required />
         <button type="submit">Create User</button>
       </form>
     )
   }
   ```

## 4. Database Integration (P1)

1. CRITICAL: Connection handling:
   ```typescript
   // lib/db.ts
   import { PrismaClient } from "@prisma/client"
   
   const globalForPrisma = globalThis as unknown as {
     prisma: PrismaClient | undefined
   }
   
   export const prisma =
     globalForPrisma.prisma ??
     new PrismaClient({
       log: process.env.NODE_ENV === "development" ? ["query", "error"] : ["error"],
     })
   
   if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma
   ```

2. REQUIRED: Repository pattern:
   ```typescript
   // lib/repositories/user.ts
   import { prisma } from "@/lib/db"
   
   export class UserRepository {
     async findMany(options = {}) {
       return prisma.user.findMany(options)
     }
     
     async create(data: unknown) {
       return prisma.user.create({ data })
     }
     
     async update(id: string, data: unknown) {
       return prisma.user.update({ where: { id }, data })
     }
     
     async delete(id: string) {
       return prisma.user.delete({ where: { id } })
     }
   }
   ```

## 5. Bad Practices to Avoid (P1)

1. CRITICAL: Never expose internal errors:
   ```typescript
   // Bad example
   export async function GET() {
     try {
       const result = await db.query("SELECT * FROM users")
       return NextResponse.json(result)
     } catch (error) {
       // DON'T DO THIS: Exposes internal error details
       return NextResponse.json({ error: error.message }, { status: 500 })
     }
   }
   
   // Good example
   export async function GET() {
     try {
       const result = await db.query("SELECT * FROM users")
       return NextResponse.json({ data: result, error: null })
     } catch (error) {
       console.error("Database error:", error)
       return NextResponse.json(
         { data: null, error: { code: "INTERNAL_ERROR", message: "Internal server error" }},
         { status: 500 }
       )
     }
   }
   ```

2. REQUIRED: Avoid mixing concerns:
   ```typescript
   // Bad example - mixing database and validation logic
   export async function POST(request: Request) {
     const body = await request.json()
     const user = await prisma.user.create({ data: body }) // DON'T DO THIS
     return NextResponse.json(user)
   }
   
   // Good example - separation of concerns
   export async function POST(request: Request) {
     const body = await request.json()
     const result = UserSchema.safeParse(body)
     
     if (!result.success) {
       return NextResponse.json(
         { error: { code: "VALIDATION_ERROR", message: "Invalid data" }},
         { status: 400 }
       )
     }
     
     const userRepository = new UserRepository()
     const user = await userRepository.create(result.data)
     return NextResponse.json({ data: user, error: null })
   }
   ``` 