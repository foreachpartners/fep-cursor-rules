---
description: Guidelines for implementing API routes, data fetching, and state management in Next.js applications. Apply when building server-side APIs, client-side data access, and data caching.
globs:
alwaysApply: false
---

# Next.js API and Data Layer Guidelines

This file complements the type safety rules in @3-nextjs-type-system.mdc and @14-nextjs-type-safety.mdc, focusing specifically on API implementation and data management.

## 1. API Route Implementation (P0)

1. CRITICAL: Route handlers structure:
   ```typescript
   // app/api/users/route.ts
   import { NextResponse } from "next/server"
   import { db } from "@/lib/db"
   
   export async function GET() {
     try {
       const users = await db.user.findMany()
       
       return NextResponse.json({
         data: users,
         error: null,
       })
     } catch (error) {
       console.error("Failed to fetch users:", error)
       
       return NextResponse.json(
         { 
           data: null, 
           error: {
             code: "INTERNAL_SERVER_ERROR",
             message: "Failed to fetch users",
           },
         },
         { status: 500 }
       )
     }
   }
   
   export async function POST(request: Request) {
     try {
       const body = await request.json()
       
       // Validation should be implemented here
       
       const user = await db.user.create({
         data: body,
       })
       
       return NextResponse.json(
         { data: user, error: null },
         { status: 201 }
       )
     } catch (error) {
       console.error("Failed to create user:", error)
       
       return NextResponse.json(
         { 
           data: null, 
           error: {
             code: "INTERNAL_SERVER_ERROR",
             message: "Failed to create user",
           },
         },
         { status: 500 }
       )
     }
   }
   ```

2. REQUIRED: Dynamic route handlers:
   ```typescript
   // app/api/users/[id]/route.ts
   import { NextResponse } from "next/server"
   import { db } from "@/lib/db"
   
   export async function GET(
     request: Request,
     { params }: { params: { id: string } }
   ) {
     try {
       const user = await db.user.findUnique({
         where: { id: params.id },
       })
       
       if (!user) {
         return NextResponse.json(
           {
             data: null,
             error: {
               code: "NOT_FOUND",
               message: "User not found",
             },
           },
           { status: 404 }
         )
       }
       
       return NextResponse.json({ data: user, error: null })
     } catch (error) {
       console.error(`Failed to fetch user ${params.id}:`, error)
       
       return NextResponse.json(
         {
           data: null,
           error: {
             code: "INTERNAL_SERVER_ERROR",
             message: "Failed to fetch user",
           },
         },
         { status: 500 }
       )
     }
   }
   ```

## 2. API Client Implementation (P0)

1. CRITICAL: Base API client:
   ```typescript
   // lib/api-client.ts
   export interface ApiResponse<T> {
     data: T | null
     error: ApiError | null
   }
   
   export interface ApiError {
     code: string
     message: string
     details?: Record<string, unknown>
   }
   
   export class ApiClient {
     private baseUrl: string
     private defaultHeaders: Record<string, string>
     
     constructor(
       baseUrl = "/api",
       defaultHeaders: Record<string, string> = {}
     ) {
       this.baseUrl = baseUrl
       this.defaultHeaders = {
         "Content-Type": "application/json",
         ...defaultHeaders,
       }
     }
     
     async get<T>(
       endpoint: string,
       options?: RequestInit
     ): Promise<ApiResponse<T>> {
       return this.request<T>(endpoint, {
         method: "GET",
         ...options,
       })
     }
     
     async post<T, U = unknown>(
       endpoint: string,
       data: U,
       options?: RequestInit
     ): Promise<ApiResponse<T>> {
       return this.request<T>(endpoint, {
         method: "POST",
         body: JSON.stringify(data),
         ...options,
       })
     }
     
     async put<T, U = unknown>(
       endpoint: string,
       data: U,
       options?: RequestInit
     ): Promise<ApiResponse<T>> {
       return this.request<T>(endpoint, {
         method: "PUT",
         body: JSON.stringify(data),
         ...options,
       })
     }
     
     async delete<T>(
       endpoint: string,
       options?: RequestInit
     ): Promise<ApiResponse<T>> {
       return this.request<T>(endpoint, {
         method: "DELETE",
         ...options,
       })
     }
     
     private async request<T>(
       endpoint: string,
       options: RequestInit = {}
     ): Promise<ApiResponse<T>> {
       try {
         const url = `${this.baseUrl}/${endpoint.startsWith("/") ? endpoint.slice(1) : endpoint}`
         
         const response = await fetch(url, {
           ...options,
           headers: {
             ...this.defaultHeaders,
             ...options.headers,
           },
         })
         
         const result = await response.json()
         
         return result as ApiResponse<T>
       } catch (error) {
         console.error(`API request failed for ${endpoint}:`, error)
         
         return {
           data: null,
           error: {
             code: "REQUEST_FAILED",
             message: "Failed to execute request",
           },
         }
       }
     }
   }
   
   // Create and export singleton instance
   export const apiClient = new ApiClient()
   ```

2. REQUIRED: Service modules:
   ```typescript
   // lib/services/user-service.ts
   import { apiClient } from "@/lib/api-client"
   
   export interface User {
     id: string
     name: string
     email: string
     role: string
   }
   
   export interface CreateUserData {
     name: string
     email: string
     password: string
   }
   
   export interface UpdateUserData {
     name?: string
     email?: string
   }
   
   export const userService = {
     getAll: () => apiClient.get<User[]>("users"),
     
     getById: (id: string) => apiClient.get<User>(`users/${id}`),
     
     create: (data: CreateUserData) => apiClient.post<User, CreateUserData>("users", data),
     
     update: (id: string, data: UpdateUserData) => 
       apiClient.put<User, UpdateUserData>(`users/${id}`, data),
     
     delete: (id: string) => apiClient.delete<void>(`users/${id}`),
   }
   ```

## 3. Data Fetching with TanStack Query (P0)

1. CRITICAL: Setup and configuration:
   ```typescript
   // lib/tanstack-query.tsx
   "use client"
   
   import { useState } from "react"
   import { QueryClient, QueryClientProvider } from "@tanstack/react-query"
   import { ReactQueryDevtools } from "@tanstack/react-query-devtools"
   
   export function TanStackProvider({
     children,
   }: {
     children: React.ReactNode
   }) {
     const [queryClient] = useState(
       () =>
         new QueryClient({
           defaultOptions: {
             queries: {
               staleTime: 60 * 1000, // 1 minute
               refetchOnWindowFocus: false,
               retry: 1,
             },
           },
         })
     )
   
     return (
       <QueryClientProvider client={queryClient}>
         {children}
         <ReactQueryDevtools initialIsOpen={false} />
       </QueryClientProvider>
     )
   }
   ```

2. REQUIRED: Hooks for data fetching:
   ```typescript
   // lib/hooks/use-users.ts
   import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query"
   import { userService, type User, type CreateUserData, type UpdateUserData } from "@/lib/services/user-service"
   
   // Query keys
   export const userKeys = {
     all: ["users"] as const,
     lists: () => [...userKeys.all, "list"] as const,
     list: (filters: Record<string, unknown>) => [...userKeys.lists(), { filters }] as const,
     details: () => [...userKeys.all, "detail"] as const,
     detail: (id: string) => [...userKeys.details(), id] as const,
   }
   
   // Hooks
   export function useUsers() {
     return useQuery({
       queryKey: userKeys.lists(),
       queryFn: () => userService.getAll(),
     })
   }
   
   export function useUser(id: string) {
     return useQuery({
       queryKey: userKeys.detail(id),
       queryFn: () => userService.getById(id),
       enabled: !!id,
     })
   }
   
   export function useCreateUser() {
     const queryClient = useQueryClient()
     
     return useMutation({
       mutationFn: (data: CreateUserData) => userService.create(data),
       onSuccess: () => {
         queryClient.invalidateQueries({ queryKey: userKeys.lists() })
       },
     })
   }
   
   export function useUpdateUser(id: string) {
     const queryClient = useQueryClient()
     
     return useMutation({
       mutationFn: (data: UpdateUserData) => userService.update(id, data),
       onSuccess: (data) => {
         queryClient.invalidateQueries({ queryKey: userKeys.detail(id) })
         queryClient.invalidateQueries({ queryKey: userKeys.lists() })
       },
     })
   }
   
   export function useDeleteUser() {
     const queryClient = useQueryClient()
     
     return useMutation({
       mutationFn: (id: string) => userService.delete(id),
       onSuccess: () => {
         queryClient.invalidateQueries({ queryKey: userKeys.lists() })
       },
     })
   }
   ```

## 4. Server-Side Data Fetching (P0)

1. CRITICAL: Data fetching in Server Components:
   ```typescript
   // app/users/page.tsx
   import { db } from "@/lib/db"
   import { UserList } from "@/components/features/users/user-list"
   
   export default async function UsersPage() {
     // Direct database access in Server Component
     const users = await db.user.findMany({
       orderBy: { createdAt: "desc" },
     })
     
     return (
       <div className="container py-8">
         <h1 className="text-2xl font-bold mb-6">Users</h1>
         <UserList initialUsers={users} />
       </div>
     )
   }
   ```

2. REQUIRED: Data fetching functions:
   ```typescript
   // lib/data.ts
   import { cache } from "react"
   import { db } from "@/lib/db"
   
   export const getUser = cache(async (id: string) => {
     return db.user.findUnique({
       where: { id },
       include: {
         profile: true,
       },
     })
   })
   
   export const getUsers = cache(async (limit = 10) => {
     return db.user.findMany({
       take: limit,
       orderBy: { createdAt: "desc" },
       include: {
         profile: true,
       },
     })
   })
   ```

3. ESSENTIAL: Server actions:
   ```typescript
   // lib/actions/user-actions.ts
   "use server"
   
   import { revalidatePath } from "next/cache"
   import { db } from "@/lib/db"
   import { redirect } from "next/navigation"
   import { z } from "zod"
   
   const UserSchema = z.object({
     name: z.string().min(2, "Name must be at least 2 characters"),
     email: z.string().email("Invalid email address"),
   })
   
   export async function createUser(formData: FormData) {
     const rawData = {
       name: formData.get("name"),
       email: formData.get("email"),
     }
     
     // Validate input
     const validationResult = UserSchema.safeParse(rawData)
     
     if (!validationResult.success) {
       return {
         error: validationResult.error.format(),
         data: null,
       }
     }
     
     try {
       const data = validationResult.data
       
       const user = await db.user.create({
         data,
       })
       
       revalidatePath("/users")
       redirect("/users")
       
       return { data: user, error: null }
     } catch (error) {
       console.error("Failed to create user:", error)
       
       return {
         error: {
           message: "Failed to create user",
         },
         data: null,
       }
     }
   }
   ```

## 5. State Management with Zustand (P1)

1. CRITICAL: Store setup:
   ```typescript
   // lib/store/user-store.ts
   import { create } from "zustand"
   import { persist } from "zustand/middleware"
   
   export interface User {
     id: string
     name: string
     email: string
   }
   
   interface UserState {
     currentUser: User | null
     isLoading: boolean
     error: string | null
     setCurrentUser: (user: User | null) => void
     setLoading: (isLoading: boolean) => void
     setError: (error: string | null) => void
     logout: () => void
   }
   
   export const useUserStore = create<UserState>()(
     persist(
       (set) => ({
         currentUser: null,
         isLoading: false,
         error: null,
         setCurrentUser: (user) => set({ currentUser: user, error: null }),
         setLoading: (isLoading) => set({ isLoading }),
         setError: (error) => set({ error }),
         logout: () => set({ currentUser: null, error: null }),
       }),
       {
         name: "user-store",
       }
     )
   )
   ```

2. REQUIRED: Combining stores:
   ```typescript
   // lib/store/index.ts
   import { useUserStore } from "./user-store"
   import { useCartStore } from "./cart-store"
   import { useUIStore } from "./ui-store"
   
   export {
     useUserStore,
     useCartStore,
     useUIStore,
   }
   ```

3. ESSENTIAL: Store usage in components:
   ```typescript
   // components/features/auth/user-profile.tsx
   "use client"
   
   import { useUserStore } from "@/lib/store"
   
   export function UserProfile() {
     const { currentUser, logout } = useUserStore()
     
     if (!currentUser) {
       return <div>Not logged in</div>
     }
     
     return (
       <div className="rounded-lg border p-4">
         <h2 className="text-xl font-semibold">{currentUser.name}</h2>
         <p className="text-muted-foreground">{currentUser.email}</p>
         <button 
           className="mt-4 bg-destructive text-destructive-foreground px-3 py-1 rounded"
           onClick={logout}
         >
           Logout
         </button>
       </div>
     )
   }
   ```

## 6. Error Handling (P1)

1. CRITICAL: Standard error response format:
   ```typescript
   // lib/errors.ts
   export interface ApiError {
     code: string
     message: string
     details?: Record<string, unknown>
   }
   
   export class AppError extends Error {
     code: string
     details?: Record<string, unknown>
     
     constructor(code: string, message: string, details?: Record<string, unknown>) {
       super(message)
       this.name = "AppError"
       this.code = code
       this.details = details
     }
     
     toJSON(): ApiError {
       return {
         code: this.code,
         message: this.message,
         details: this.details,
       }
     }
   }
   
   export const ErrorCodes = {
     NOT_FOUND: "NOT_FOUND",
     UNAUTHORIZED: "UNAUTHORIZED",
     FORBIDDEN: "FORBIDDEN",
     VALIDATION_FAILED: "VALIDATION_FAILED",
     INTERNAL_SERVER_ERROR: "INTERNAL_SERVER_ERROR",
     BAD_REQUEST: "BAD_REQUEST",
   } as const
   
   export type ErrorCode = typeof ErrorCodes[keyof typeof ErrorCodes]
   ```

2. REQUIRED: Client-side error handling:
   ```typescript
   // components/features/users/user-form.tsx (excerpt)
   import { useState } from "react"
   import { useCreateUser } from "@/lib/hooks/use-users"
   
   export function UserForm() {
     const [formData, setFormData] = useState({
       name: "",
       email: "",
     })
     
     const createUser = useCreateUser()
     
     const handleSubmit = async (e: React.FormEvent) => {
       e.preventDefault()
       
       try {
         const result = await createUser.mutateAsync({
           name: formData.name,
           email: formData.email,
           password: "temporary",
         })
         
         if (result.error) {
           throw new Error(result.error.message)
         }
         
         // Success handling
       } catch (error) {
         // Error handling
         console.error("Failed to create user:", error)
       }
     }
     
     return (
       <form onSubmit={handleSubmit}>
         {/* Form fields */}
       </form>
     )
   }
   ```

3. ESSENTIAL: Server-side error handling:
   ```typescript
   // middleware.ts
   import { NextResponse } from "next/server"
   import type { NextRequest } from "next/server"
   
   export function middleware(request: NextRequest) {
     try {
       // Middleware logic
       
       return NextResponse.next()
     } catch (error) {
       console.error("Middleware error:", error)
       
       return NextResponse.json(
         {
           data: null,
           error: {
             code: "MIDDLEWARE_ERROR",
             message: "Something went wrong",
           },
         },
         { status: 500 }
       )
     }
   }
   ```

## 7. API Documentation (P2)

1. REQUIRED: API documentation format:
   ```typescript
   /**
    * @api {get} /api/users Get all users
    * @apiName GetUsers
    * @apiGroup User
    *
    * @apiSuccess {Object} response API response
    * @apiSuccess {User[]} response.data List of users
    * @apiSuccess {Object} response.error Error object (null if no error)
    *
    * @apiSuccessExample {json} Success-Response:
    *     HTTP/1.1 200 OK
    *     {
    *       "data": [
    *         {
    *           "id": "1",
    *           "name": "John Doe",
    *           "email": "john@example.com"
    *         }
    *       ],
    *       "error": null
    *     }
    */
   export async function GET() {
     // Implementation
   }
   ```

2. RECOMMENDED: API client documentation:
   ```typescript
   // lib/services/user-service.ts (documentation for functions)
   export const userService = {
     /**
      * Get all users
      * @returns Promise with user list response
      */
     getAll: () => apiClient.get<User[]>("users"),
     
     /**
      * Get user by ID
      * @param id - User ID
      * @returns Promise with user data response
      */
     getById: (id: string) => apiClient.get<User>(`users/${id}`),
     
     // More functions...
   }
   ```

## 8. Data Validation (P2)

1. REQUIRED: Request validation:
   ```typescript
   // lib/validation.ts
   import { z } from "zod"
   import { NextResponse } from "next/server"
   import type { NextRequest } from "next/server"
   
   export async function validateRequest<T>(
     request: NextRequest,
     schema: z.Schema<T>
   ): Promise<{ data: T | null; error: NextResponse | null }> {
     try {
       const body = await request.json()
       const data = schema.parse(body)
       
       return { data, error: null }
     } catch (error) {
       if (error instanceof z.ZodError) {
         return {
           data: null,
           error: NextResponse.json(
             {
               data: null,
               error: {
                 code: "VALIDATION_FAILED",
                 message: "Validation failed",
                 details: error.format(),
               },
             },
             { status: 400 }
           ),
         }
       }
       
       return {
         data: null,
         error: NextResponse.json(
           {
             data: null,
             error: {
               code: "INTERNAL_SERVER_ERROR",
               message: "Failed to process request",
             },
           },
           { status: 500 }
         ),
       }
     }
   }
   ```

2. RECOMMENDED: Schema definitions:
   ```typescript
   // lib/schemas/user-schema.ts
   import { z } from "zod"
   
   export const CreateUserSchema = z.object({
     name: z.string().min(2, "Name must be at least 2 characters"),
     email: z.string().email("Invalid email address"),
     password: z.string().min(8, "Password must be at least 8 characters"),
   })
   
   export const UpdateUserSchema = z.object({
     name: z.string().min(2, "Name must be at least 2 characters").optional(),
     email: z.string().email("Invalid email address").optional(),
   })
   
   export type CreateUserInput = z.infer<typeof CreateUserSchema>
   export type UpdateUserInput = z.infer<typeof UpdateUserSchema>
   ``` 