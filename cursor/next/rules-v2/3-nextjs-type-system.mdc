---
description: Guidelines for TypeScript configuration, type definitions, and patterns in Next.js applications. Apply when setting up the project's type system, creating shared types, and ensuring proper type inference.
globs:
alwaysApply: false
---

# Next.js Type System Guidelines

## 1. TypeScript Configuration (P0)

1. CRITICAL: Required tsconfig.json settings:
   ```json
   {
     "compilerOptions": {
       "target": "es2017",
       "lib": ["dom", "dom.iterable", "esnext"],
       "allowJs": true,
       "skipLibCheck": true,
       "strict": true,
       "forceConsistentCasingInFileNames": true,
       "noEmit": true,
       "esModuleInterop": true,
       "module": "esnext",
       "moduleResolution": "bundler",
       "resolveJsonModule": true,
       "isolatedModules": true,
       "jsx": "preserve",
       "incremental": true,
       "plugins": [
         {
           "name": "next"
         }
       ],
       "paths": {
         "@/*": ["./*"]
       }
     },
     "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
     "exclude": ["node_modules"]
   }
   ```

2. REQUIRED: Additional strictness options:
   ```json
   {
     "compilerOptions": {
       // ... existing options
       "noImplicitAny": true,
       "noImplicitThis": true,
       "strictNullChecks": true,
       "strictFunctionTypes": true,
       "strictBindCallApply": true,
       "noFallthroughCasesInSwitch": true
     }
   }
   ```

3. ESSENTIAL: Path aliases configuration:
   ```json
   {
     "compilerOptions": {
       // ... existing options
       "baseUrl": ".",
       "paths": {
         "@/components/*": ["components/*"],
         "@/lib/*": ["lib/*"],
         "@/styles/*": ["styles/*"],
         "@/types/*": ["types/*"],
         "@/app/*": ["app/*"],
         "@/public/*": ["public/*"]
       }
     }
   }
   ```

## 2. Type Declarations (P0)

1. CRITICAL: Organization of type files:
   ```
   /types
     /api           # API related types
       request.ts   # Request types
       response.ts  # Response types
     /models        # Domain models
     /components    # Component props
     /hooks         # Hook return types
     /context       # Context types
     /utils         # Utility types
     index.ts       # Re-exports
   ```

2. REQUIRED: Common base types:
   ```tsx
   // types/api/response.ts
   export interface ApiResponse<T> {
     data: T;
     meta?: {
       page?: number;
       limit?: number;
       total?: number;
     };
   }
   
   export interface ApiError {
     code: string;
     message: string;
     details?: Record<string, unknown>;
   }
   
   // types/models/user.ts
   export interface User {
     id: string;
     name: string;
     email: string;
     role: UserRole;
     createdAt: string;
     updatedAt: string;
   }
   
   // Use enum for role as defined in @14-nextjs-type-safety.mdc section 1
   ```

3. ESSENTIAL: Export and import best practices:
   ```tsx
   // Good: Named exports for explicit imports
   // types/index.ts
   export * from './api/response';
   export * from './models/user';
   
   // Component usage
   import { ApiResponse, User } from '@/types';
   ```

## 3. Next.js Specific Types (P0)

1. CRITICAL: Route handlers:
   ```tsx
   // app/api/users/route.ts
   import { NextRequest, NextResponse } from 'next/server';
   import { User } from '@/types';
   
   export async function GET(
     request: NextRequest
   ): Promise<NextResponse<{ users: User[] }>> {
     // Implementation
     return NextResponse.json({ users: [] });
   }
   
   export async function POST(
     request: NextRequest
   ): Promise<NextResponse<{ user: User } | { error: string }>> {
     try {
       const data = await request.json();
       // Validation and processing
       return NextResponse.json({ user: newUser });
     } catch (error) {
       return NextResponse.json(
         { error: 'Failed to create user' },
         { status: 400 }
       );
     }
   }
   ```

2. REQUIRED: Page and layout props:
   ```tsx
   // app/[slug]/page.tsx
   export interface PageProps {
     params: { slug: string };
     searchParams: { [key: string]: string | string[] | undefined };
   }
   
   export default function Page({ params, searchParams }: PageProps) {
     // Implementation
   }
   
   // app/[slug]/layout.tsx
   export interface LayoutProps {
     children: React.ReactNode;
     params: { slug: string };
   }
   
   export default function Layout({ children, params }: LayoutProps) {
     // Implementation
   }
   ```

3. ESSENTIAL: Static generation typing:
   ```tsx
   // app/blog/[slug]/page.tsx
   import { Metadata } from 'next';
   
   interface Post {
     title: string;
     description: string;
     slug: string;
   }
   
   interface Params {
     slug: string;
   }
   
   export async function generateMetadata(
     { params }: { params: Params }
   ): Promise<Metadata> {
     const post = await getPost(params.slug);
     
     return {
       title: post.title,
       description: post.description,
     };
   }
   
   export async function generateStaticParams(): Promise<Params[]> {
     const posts = await getPosts();
     
     return posts.map((post) => ({
       slug: post.slug,
     }));
   }
   ```

## 4. Generic Patterns (P1)

1. CRITICAL: Component prop typing:
   ```tsx
   // Common pattern for component props
   import { HTMLAttributes } from 'react';
   
   interface ButtonProps extends HTMLAttributes<HTMLButtonElement> {
     variant?: 'primary' | 'secondary' | 'outline';
     size?: 'sm' | 'md' | 'lg';
     isLoading?: boolean;
   }
   
   export function Button({
     variant = 'primary',
     size = 'md',
     isLoading = false,
     children,
     ...props
   }: ButtonProps) {
     // Implementation
   }
   ```

2. REQUIRED: Form handling:
   ```tsx
   // For form state
   interface FormState<T> {
     values: T;
     errors: Partial<Record<keyof T, string>>;
     touched: Partial<Record<keyof T, boolean>>;
     isSubmitting: boolean;
     isValid: boolean;
   }
   
   // For form submission
   interface FormSubmitHandlerProps<T> {
     onSubmit: (values: T) => Promise<void> | void;
     onSuccess?: () => void;
     onError?: (error: unknown) => void;
   }
   
   function useForm<T extends Record<string, any>>(
     initialValues: T,
     validate: (values: T) => Partial<Record<keyof T, string>>
   ): FormState<T> & {
     handleChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
     handleSubmit: (props: FormSubmitHandlerProps<T>) => (e: React.FormEvent) => void;
   } {
     // Implementation
   }
   ```

3. ESSENTIAL: API client types:
   ```tsx
   // Generic API client with type safety
   type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
   
   interface FetchOptions<TBody = unknown> extends Omit<RequestInit, 'body'> {
     params?: Record<string, string | number | boolean | undefined>;
     body?: TBody;
   }
   
   async function fetchApi<TResponse, TBody = unknown>(
     endpoint: string,
     method: HttpMethod = 'GET',
     options?: FetchOptions<TBody>
   ): Promise<TResponse> {
     // Implementation
   }
   
   // Usage
   interface UserCreateRequest {
     name: string;
     email: string;
   }
   
   const user = await fetchApi<User, UserCreateRequest>(
     '/api/users',
     'POST',
     { body: { name: 'John', email: 'john@example.com' } }
   );
   ```

## 5. Type Inference (P1)

1. CRITICAL: Leveraging inference:
   ```tsx
   // Good: Let TypeScript infer types
   const users = ['user1', 'user2', 'user3'];
   users.forEach(user => {
     // user is inferred as string
   });
   
   // Good: Use ReturnType for complex functions
   function createUserManager() {
     return {
       getUser: (id: string) => ({ id, name: 'User' }),
       updateUser: (id: string, data: Partial<User>) => ({ id, ...data }),
     };
   }
   
   type UserManager = ReturnType<typeof createUserManager>;
   ```

2. REQUIRED: React hook inference:
   ```tsx
   // Custom hook with proper typing
   function useCounter(initialValue = 0) {
     const [count, setCount] = useState(initialValue);
     
     const increment = () => setCount(c => c + 1);
     const decrement = () => setCount(c => c - 1);
     const reset = () => setCount(initialValue);
     
     return { count, increment, decrement, reset } as const;
   }
   
   // Usage with proper inference
   const { count, increment } = useCounter(10);
   // count is inferred as number
   ```

3. ESSENTIAL: Event handlers:
   ```tsx
   // Event handler inference
   function Button({ onClick }: { onClick?: React.MouseEventHandler<HTMLButtonElement> }) {
     return <button onClick={onClick}>Click me</button>;
   }
   
   // Usage
   <Button onClick={(e) => {
     // e is properly typed as React.MouseEvent<HTMLButtonElement>
     console.log(e.currentTarget.id);
   }} />
   ```

## 6. Advanced TypeScript Features (P2)

1. REQUIRED: Discriminated unions:
   ```tsx
   // For state management
   type RequestState<T> =
     | { status: 'idle' }
     | { status: 'loading' }
     | { status: 'success'; data: T }
     | { status: 'error'; error: Error };
   
   // Usage
   function UserProfile({ userId }: { userId: string }) {
     const [state, setState] = useState<RequestState<User>>({ status: 'idle' });
     
     useEffect(() => {
       async function loadUser() {
         setState({ status: 'loading' });
         try {
           const user = await fetchUser(userId);
           setState({ status: 'success', data: user });
         } catch (error) {
           setState({ status: 'error', error: error as Error });
         }
       }
       
       loadUser();
     }, [userId]);
     
     // Type guard usage
     if (state.status === 'loading') {
       return <LoadingSpinner />;
     }
     
     if (state.status === 'error') {
       return <ErrorMessage message={state.error.message} />;
     }
     
     if (state.status === 'success') {
       return <UserDetails user={state.data} />;
     }
     
     return <p>Click to load user</p>;
   }
   ```

2. RECOMMENDED: Utility types:
   ```tsx
   // Common utility types
   
   // Make specific properties required
   type RequireFields<T, K extends keyof T> = T & {
     [P in K]-?: NonNullable<T[P]>
   };
   
   // Make specific properties optional
   type PartialFields<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
   
   // Deep partial type
   type DeepPartial<T> = T extends object ? {
     [P in keyof T]?: DeepPartial<T[P]>;
   } : T;
   
   // Usage examples
   interface User {
     id?: string;
     name: string;
     email: string;
     address?: {
       street: string;
       city: string;
       country: string;
     };
   }
   
   // User with required id
   type UserWithId = RequireFields<User, 'id'>;
   
   // User with optional name and email
   type OptionalUser = PartialFields<User, 'name' | 'email'>;
   
   // Deep partial user for updates
   type UserUpdate = DeepPartial<User>;
   ```

## 7. Type Declarations for External Libraries (P2)

1. REQUIRED: Creating declarations for missing types:
   ```tsx
   // types/declarations.d.ts
   
   // Declare module for a library without types
   declare module 'untyped-library' {
     export function doSomething(value: string): Promise<string>;
     export function processData<T>(data: T): T;
     
     export interface Options {
       timeout?: number;
       retries?: number;
     }
     
     export default function initialize(options?: Options): void;
   }
   
   // Extending existing modules
   declare module 'next/server' {
     interface NextRequest {
       user?: {
         id: string;
         role: string;
       };
     }
   }
   ```

2. RECOMMENDED: Module augmentation:
   ```tsx
   // types/next-auth.d.ts
   import 'next-auth';
   
   // Extending session
   declare module 'next-auth' {
     interface Session {
       user: {
         id: string;
         name: string;
         email: string;
         role: string;
         permissions: string[];
       }
     }
   }
   
   // Extending JWT
   declare module 'next-auth/jwt' {
     interface JWT {
       id: string;
       role: string;
       permissions: string[];
     }
   }
   ```

## 8. Strict Type Safety (P2)

1. REQUIRED: Follow specific strict type safety rules as detailed in @14-nextjs-type-safety.mdc
2. CRITICAL: For string literals, enums, and constants please refer to @14-nextjs-type-safety.mdc section 1
3. ESSENTIAL: For typing events, actions, and API parameters see @14-nextjs-type-safety.mdc sections 3, 4, and 6 