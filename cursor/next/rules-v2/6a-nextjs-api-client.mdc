---
description: Guidelines for implementing client-side data fetching and state management in Next.js applications. Apply when building API clients, managing server state, or implementing data caching.
globs:
alwaysApply: false
---

# Next.js Client API Guidelines

## 1. Purpose (P0)

These guidelines ensure consistent and efficient implementation of client-side data fetching and state management. Apply when creating API clients, implementing data caching, or managing server state with TanStack Query.

## 2. API Client Structure (P0)

1. CRITICAL: Base client setup:
   ```typescript
   // lib/api/client.ts
   import { AppError } from "@/lib/errors"
   
   export class ApiClient {
     private baseUrl: string
     
     constructor(baseUrl = "/api") {
       this.baseUrl = baseUrl
     }
     
     async request<T>(path: string, options: RequestInit = {}): Promise<T> {
       const response = await fetch(`${this.baseUrl}${path}`, {
         ...options,
         headers: {
           "Content-Type": "application/json",
           ...options.headers,
         },
       })
       
       const data = await response.json()
       
       if (!response.ok) {
         throw new AppError(
           data.error?.code || "API_ERROR",
           data.error?.message || "API request failed",
           data.error?.details
         )
       }
       
       return data
     }
     
     async get<T>(path: string, options?: RequestInit) {
       return this.request<T>(path, { ...options, method: "GET" })
     }
     
     async post<T>(path: string, body: unknown, options?: RequestInit) {
       return this.request<T>(path, {
         ...options,
         method: "POST",
         body: JSON.stringify(body),
       })
     }
   }
   
   export const apiClient = new ApiClient()
   ```

2. REQUIRED: Resource-specific clients:
   ```typescript
   // lib/api/users.ts
   import { apiClient } from "./client"
   import { z } from "zod"
   
   const UserSchema = z.object({
     id: z.string(),
     name: z.string(),
     email: z.string().email(),
   })
   
   export class UserApi {
     async getUsers() {
       const response = await apiClient.get("/users")
       return UserSchema.array().parse(response.data)
     }
     
     async createUser(data: z.infer<typeof UserSchema>) {
       const response = await apiClient.post("/users", data)
       return UserSchema.parse(response.data)
     }
   }
   ```

## 3. TanStack Query Integration (P0)

1. CRITICAL: Query hooks:
   ```typescript
   // hooks/queries/useUsers.ts
   import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query"
   import { UserApi } from "@/lib/api/users"
   
   const userApi = new UserApi()
   
   export function useUsers() {
     return useQuery({
       queryKey: ["users"],
       queryFn: () => userApi.getUsers(),
     })
   }
   
   export function useCreateUser() {
     const queryClient = useQueryClient()
     
     return useMutation({
       mutationFn: userApi.createUser,
       onSuccess: () => {
         queryClient.invalidateQueries({ queryKey: ["users"] })
       },
     })
   }
   ```

2. REQUIRED: Query provider setup:
   ```typescript
   // app/providers.tsx
   import { QueryClient, QueryClientProvider } from "@tanstack/react-query"
   import { ReactQueryDevtools } from "@tanstack/react-query-devtools"
   
   const queryClient = new QueryClient({
     defaultOptions: {
       queries: {
         staleTime: 60 * 1000,
         retry: 1,
       },
     },
   })
   
   export function Providers({ children }: { children: React.ReactNode }) {
     return (
       <QueryClientProvider client={queryClient}>
         {children}
         {process.env.NODE_ENV === "development" && <ReactQueryDevtools />}
       </QueryClientProvider>
     )
   }
   ```

## 4. Error Handling (P1)

1. CRITICAL: Error boundaries:
   ```typescript
   // components/ErrorBoundary.tsx
   "use client"
   
   import { useQueryErrorResetBoundary } from "@tanstack/react-query"
   import { ErrorBoundary as ReactErrorBoundary } from "react-error-boundary"
   
   export function ErrorBoundary({ children }: { children: React.ReactNode }) {
     const { reset } = useQueryErrorResetBoundary()
     
     return (
       <ReactErrorBoundary
         onReset={reset}
         fallbackRender={({ error, resetErrorBoundary }) => (
           <div role="alert">
             <p>Something went wrong:</p>
             <pre>{error.message}</pre>
             <button onClick={resetErrorBoundary}>Try again</button>
           </div>
         )}
       >
         {children}
       </ReactErrorBoundary>
     )
   }
   ```

## 5. Bad Practices to Avoid (P1)

1. CRITICAL: Avoid direct fetch calls:
   ```typescript
   // Bad example
   function UserList() {
     const [users, setUsers] = useState([])
     
     useEffect(() => {
       // DON'T DO THIS: Direct fetch without proper error handling
       fetch("/api/users")
         .then(res => res.json())
         .then(data => setUsers(data))
     }, [])
     
     return <ul>{users.map(user => <li key={user.id}>{user.name}</li>)}</ul>
   }
   
   // Good example
   function UserList() {
     const { data: users, isLoading, error } = useUsers()
     
     if (isLoading) return <div>Loading...</div>
     if (error) return <div>Error: {error.message}</div>
     
     return (
       <ul>
         {users?.map(user => <li key={user.id}>{user.name}</li>)}
       </ul>
     )
   }
   ```

2. REQUIRED: Avoid mixing client and server code:
   ```typescript
   // Bad example - mixing server and client code
   // DON'T DO THIS: Component with both server and client logic
   async function UserProfile({ userId }: { userId: string }) {
     const user = await prisma.user.findUnique({ where: { id: userId }})
     
     return (
       <div>
         <h1>{user.name}</h1>
         <button onClick={() => fetch(`/api/users/${userId}`)}>
           Refresh
         </button>
       </div>
     )
   }
   
   // Good example - separation of concerns
   // Server component
   async function UserProfile({ userId }: { userId: string }) {
     const user = await prisma.user.findUnique({ where: { id: userId }})
     return <UserProfileClient user={user} />
   }
   
   // Client component
   "use client"
   function UserProfileClient({ user }: { user: User }) {
     const { refetch } = useUser(user.id)
     
     return (
       <div>
         <h1>{user.name}</h1>
         <button onClick={() => refetch()}>Refresh</button>
       </div>
     )
   }
   ``` 