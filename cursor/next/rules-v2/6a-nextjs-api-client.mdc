---
description: Guidelines for implementing client-side API integration and data fetching in Next.js applications.
globs:
alwaysApply: false
---

# Next.js Client API Guidelines

## 1. API Client (P0)

1. CRITICAL: Base client:
   ```typescript
   // lib/api-client.ts
   interface ApiResponse<T> {
     data: T | null
     error: { code: string; message: string } | null
   }
   
   export class ApiClient {
     constructor(private baseUrl = "/api") {}
     
     async request<T>(
       endpoint: string,
       options: RequestInit = {}
     ): Promise<ApiResponse<T>> {
       try {
         const url = `${this.baseUrl}/${endpoint}`
         const response = await fetch(url, {
           headers: { "Content-Type": "application/json" },
           ...options,
         })
         
         if (!response.ok) {
           throw new Error(`HTTP error! status: ${response.status}`)
         }
         
         return response.json()
       } catch (error) {
         return {
           data: null,
           error: { code: "REQUEST_FAILED", message: String(error) }
         }
       }
     }
     
     get<T>(endpoint: string) {
       return this.request<T>(endpoint)
     }
     
     post<T>(endpoint: string, data: unknown) {
       return this.request<T>(endpoint, {
         method: "POST",
         body: JSON.stringify(data),
       })
     }
     
     put<T>(endpoint: string, data: unknown) {
       return this.request<T>(endpoint, {
         method: "PUT",
         body: JSON.stringify(data),
       })
     }
     
     delete(endpoint: string) {
       return this.request(endpoint, { method: "DELETE" })
     }
   }
   
   export const api = new ApiClient()
   ```

## 2. Data Fetching (P0)

1. CRITICAL: TanStack Query setup:
   ```typescript
   // providers/query.tsx
   "use client"
   
   import { QueryClient, QueryClientProvider } from "@tanstack/react-query"
   import { ReactQueryDevtools } from "@tanstack/react-query-devtools"
   
   const queryClient = new QueryClient({
     defaultOptions: {
       queries: {
         staleTime: 60 * 1000,
         refetchOnWindowFocus: false,
         retry: 1,
       },
     },
   })
   
   export function QueryProvider({ children }: { children: React.ReactNode }) {
     return (
       <QueryClientProvider client={queryClient}>
         {children}
         {process.env.NODE_ENV === "development" && <ReactQueryDevtools />}
       </QueryClientProvider>
     )
   }
   ```

2. REQUIRED: Query hooks:
   ```typescript
   // lib/hooks/use-query.ts
   import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query"
   import { api } from "@/lib/api-client"
   
   export function createQueryKeys(resource: string) {
     return {
       all: [resource] as const,
       lists: () => [...this.all, "list"] as const,
       list: (filters: unknown) => [...this.lists(), { filters }] as const,
       details: () => [...this.all, "detail"] as const,
       detail: (id: string) => [...this.details(), id] as const,
     }
   }
   
   export function createQueryHooks<T>(resource: string) {
     const keys = createQueryKeys(resource)
     
     return {
       useList(filters = {}) {
         return useQuery({
           queryKey: keys.list(filters),
           queryFn: () => api.get(`${resource}?${new URLSearchParams(filters)}`),
         })
       },
       
       useDetail(id: string) {
         return useQuery({
           queryKey: keys.detail(id),
           queryFn: () => api.get(`${resource}/${id}`),
         })
       },
       
       useCreate() {
         const queryClient = useQueryClient()
         
         return useMutation({
           mutationFn: (data: unknown) => api.post(resource, data),
           onSuccess: () => {
             queryClient.invalidateQueries({ queryKey: keys.lists() })
           },
         })
       },
       
       useUpdate() {
         const queryClient = useQueryClient()
         
         return useMutation({
           mutationFn: ({ id, data }: { id: string; data: unknown }) =>
             api.put(`${resource}/${id}`, data),
           onSuccess: (_, { id }) => {
             queryClient.invalidateQueries({ queryKey: keys.detail(id) })
           },
         })
       },
       
       useDelete() {
         const queryClient = useQueryClient()
         
         return useMutation({
           mutationFn: (id: string) => api.delete(`${resource}/${id}`),
           onSuccess: () => {
             queryClient.invalidateQueries({ queryKey: keys.lists() })
           },
         })
       },
     }
   }
   ```

## 3. Error Handling (P1)

1. CRITICAL: Error boundary:
   ```typescript
   // components/error-boundary.tsx
   "use client"
   
   import { useEffect } from "react"
   import { useQueryErrorResetBoundary } from "@tanstack/react-query"
   
   export function ErrorBoundary({
     error,
     reset,
   }: {
     error: Error
     reset: () => void
   }) {
     const { reset: resetQueries } = useQueryErrorResetBoundary()
     
     useEffect(() => {
       console.error(error)
     }, [error])
     
     return (
       <div className="p-4 border border-red-500 rounded">
         <h2 className="text-red-500 font-bold">Something went wrong!</h2>
         <p className="text-sm text-gray-600">{error.message}</p>
         <button
           onClick={() => {
             resetQueries()
             reset()
           }}
           className="mt-4 px-4 py-2 bg-red-500 text-white rounded"
         >
           Try again
         </button>
       </div>
     )
   }
   ```

2. REQUIRED: Loading states:
   ```typescript
   // components/loading-state.tsx
   export function LoadingState() {
     return (
       <div className="flex items-center justify-center p-4">
         <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary" />
       </div>
     )
   }
   
   export function LoadingButton({ children, loading, ...props }) {
     return (
       <button
         disabled={loading}
         className="relative"
         {...props}
       >
         {loading && (
           <span className="absolute inset-0 flex items-center justify-center bg-black/10">
             <span className="animate-spin h-4 w-4 border-b-2 border-white" />
           </span>
         )}
         {children}
       </button>
     )
   }
   ```

## 4. Optimistic Updates (P2)

1. REQUIRED: Optimistic mutation:
   ```typescript
   // Example usage in hooks
   export function useOptimisticUpdate() {
     const queryClient = useQueryClient()
     
     return useMutation({
       mutationFn: ({ id, data }) => api.put(`/items/${id}`, data),
       onMutate: async ({ id, data }) => {
         await queryClient.cancelQueries({ queryKey: ["items", id] })
         
         const previousItem = queryClient.getQueryData(["items", id])
         
         queryClient.setQueryData(["items", id], {
           data: { id, ...data },
           error: null,
         })
         
         return { previousItem }
       },
       onError: (err, { id }, context) => {
         queryClient.setQueryData(["items", id], context.previousItem)
       },
       onSettled: (_, __, { id }) => {
         queryClient.invalidateQueries({ queryKey: ["items", id] })
       },
     })
   }
   ```

2. RECOMMENDED: Infinite queries:
   ```typescript
   // lib/hooks/use-infinite-query.ts
   export function useInfiniteList(resource: string) {
     return useInfiniteQuery({
       queryKey: [resource, "infinite"],
       queryFn: ({ pageParam = 1 }) =>
         api.get(`${resource}?page=${pageParam}&limit=10`),
       getNextPageParam: (lastPage, pages) => {
         if (!lastPage.data?.hasMore) return undefined
         return pages.length + 1
       },
     })
   }
   ``` 