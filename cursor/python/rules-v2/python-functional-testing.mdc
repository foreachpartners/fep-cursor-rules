---
description: Правила написания функциональных тестов для Python приложений
globs: "test_*.py,*_test.py,tests/*.py,conftest.py"
alwaysApply: true
related: ["python-testing-principles.mdc", "python-unit-testing.mdc", "python-integration-testing.mdc"]
priority: 7
---
# Правила функционального тестирования в Python

Рекомендации по написанию функциональных тестов для Python приложений. Функциональные тесты проверяют соответствие системы функциональным требованиям и пользовательским сценариям.

---

## Основные принципы функционального тестирования

1. **Тестирование с точки зрения пользователя**: Функциональные тесты проверяют систему с точки зрения конечного пользователя.
2. **Проверка бизнес-требований**: Тесты должны проверять соответствие системы бизнес-требованиям и пользовательским историям.
3. **Полный стек**: Функциональные тесты обычно проверяют всю систему целиком, включая пользовательский интерфейс, бэкенд и базу данных.
4. **Независимость от реализации**: Тесты должны быть независимы от конкретной реализации и проверять только внешнее поведение системы.
5. **Воспроизводимость**: Тесты должны быть воспроизводимыми и давать одинаковые результаты при одинаковых условиях.

## Структура функциональных тестов

### Тестирование веб-приложений с Selenium

```python
import pytest
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

@pytest.fixture
def driver():
    """Фикстура для создания драйвера Selenium."""
    # Настройка драйвера
    options = webdriver.ChromeOptions()
    options.add_argument("--headless")
    options.add_argument("--no-sandbox")
    options.add_argument("--disable-dev-shm-usage")
    
    # Создание драйвера
    driver = webdriver.Chrome(options=options)
    driver.implicitly_wait(10)
    
    yield driver
    
    # Закрытие драйвера
    driver.quit()

def test_user_registration(driver):
    """Функциональный тест для регистрации пользователя."""
    # Открытие страницы регистрации
    driver.get("http://localhost:8000/register")
    
    # Заполнение формы регистрации
    driver.find_element(By.ID, "username").send_keys("testuser")
    driver.find_element(By.ID, "email").send_keys("testuser@example.com")
    driver.find_element(By.ID, "password").send_keys("password123")
    driver.find_element(By.ID, "confirm_password").send_keys("password123")
    
    # Отправка формы
    driver.find_element(By.ID, "register-button").click()
    
    # Ожидание перенаправления на страницу входа
    WebDriverWait(driver, 10).until(
        EC.url_contains("/login")
    )
    
    # Проверка наличия сообщения об успешной регистрации
    success_message = driver.find_element(By.CLASS_NAME, "alert-success")
    assert "Registration successful" in success_message.text
    
    # Вход в систему
    driver.find_element(By.ID, "username").send_keys("testuser")
    driver.find_element(By.ID, "password").send_keys("password123")
    driver.find_element(By.ID, "login-button").click()
    
    # Ожидание перенаправления на главную страницу
    WebDriverWait(driver, 10).until(
        EC.url_contains("/dashboard")
    )
    
    # Проверка, что пользователь вошел в систему
    welcome_message = driver.find_element(By.ID, "welcome-message")
    assert "Welcome, testuser" in welcome_message.text
```

### Тестирование с использованием Page Object Pattern

```python
import pytest
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

# Page Objects
class LoginPage:
    def __init__(self, driver):
        self.driver = driver
        self.url = "http://localhost:8000/login"
    
    def navigate(self):
        self.driver.get(self.url)
        return self
    
    def login(self, username, password):
        self.driver.find_element(By.ID, "username").send_keys(username)
        self.driver.find_element(By.ID, "password").send_keys(password)
        self.driver.find_element(By.ID, "login-button").click()
        return DashboardPage(self.driver)
    
    def get_error_message(self):
        return self.driver.find_element(By.CLASS_NAME, "alert-danger").text

class DashboardPage:
    def __init__(self, driver):
        self.driver = driver
        self.url = "http://localhost:8000/dashboard"
    
    def wait_for_load(self):
        WebDriverWait(self.driver, 10).until(
            EC.url_contains("/dashboard")
        )
        return self
    
    def get_welcome_message(self):
        return self.driver.find_element(By.ID, "welcome-message").text
    
    def navigate_to_profile(self):
        self.driver.find_element(By.ID, "profile-link").click()
        return ProfilePage(self.driver)

class ProfilePage:
    def __init__(self, driver):
        self.driver = driver
        self.url = "http://localhost:8000/profile"
    
    def wait_for_load(self):
        WebDriverWait(self.driver, 10).until(
            EC.url_contains("/profile")
        )
        return self
    
    def update_profile(self, name, bio):
        self.driver.find_element(By.ID, "name").clear()
        self.driver.find_element(By.ID, "name").send_keys(name)
        self.driver.find_element(By.ID, "bio").clear()
        self.driver.find_element(By.ID, "bio").send_keys(bio)
        self.driver.find_element(By.ID, "update-profile-button").click()
        return self
    
    def get_success_message(self):
        return self.driver.find_element(By.CLASS_NAME, "alert-success").text

# Tests
@pytest.fixture
def driver():
    """Фикстура для создания драйвера Selenium."""
    options = webdriver.ChromeOptions()
    options.add_argument("--headless")
    driver = webdriver.Chrome(options=options)
    driver.implicitly_wait(10)
    yield driver
    driver.quit()

def test_login_and_update_profile(driver):
    """Функциональный тест для входа и обновления профиля."""
    # Вход в систему
    login_page = LoginPage(driver).navigate()
    dashboard_page = login_page.login("testuser", "password123").wait_for_load()
    
    # Проверка успешного входа
    assert "Welcome, testuser" in dashboard_page.get_welcome_message()
    
    # Переход на страницу профиля
    profile_page = dashboard_page.navigate_to_profile().wait_for_load()
    
    # Обновление профиля
    profile_page.update_profile("Test User", "This is my bio")
    
    # Проверка успешного обновления
    assert "Profile updated successfully" in profile_page.get_success_message()
```

### Тестирование REST API

```python
import pytest
import requests
import json

class TestAPI:
    """Класс для функционального тестирования REST API."""
    
    BASE_URL = "http://localhost:8000/api"
    
    @pytest.fixture
    def auth_token(self):
        """Фикстура для получения токена аутентификации."""
        # Аутентификация
        response = requests.post(
            f"{self.BASE_URL}/auth/login",
            json={"username": "testuser", "password": "password123"}
        )
        data = response.json()
        return data["token"]
    
    def test_get_users(self, auth_token):
        """Тест для получения списка пользователей."""
        # Отправка запроса с токеном аутентификации
        response = requests.get(
            f"{self.BASE_URL}/users",
            headers={"Authorization": f"Bearer {auth_token}"}
        )
        
        # Проверка ответа
        assert response.status_code == 200
        data = response.json()
        assert isinstance(data, list)
        assert len(data) > 0
        
        # Проверка структуры данных
        user = data[0]
        assert "id" in user
        assert "username" in user
        assert "email" in user
    
    def test_create_user(self, auth_token):
        """Тест для создания нового пользователя."""
        # Создание пользователя
        user_data = {
            "username": "newuser",
            "email": "newuser@example.com",
            "password": "password123"
        }
        
        response = requests.post(
            f"{self.BASE_URL}/users",
            json=user_data,
            headers={"Authorization": f"Bearer {auth_token}"}
        )
        
        # Проверка ответа
        assert response.status_code == 201
        data = response.json()
        assert "id" in data
        assert data["username"] == user_data["username"]
        assert data["email"] == user_data["email"]
        
        # Проверка, что пользователь был создан
        user_id = data["id"]
        response = requests.get(
            f"{self.BASE_URL}/users/{user_id}",
            headers={"Authorization": f"Bearer {auth_token}"}
        )
        assert response.status_code == 200
        assert response.json()["id"] == user_id
    
    def test_update_user(self, auth_token):
        """Тест для обновления пользователя."""
        # Создание пользователя
        user_data = {
            "username": "updateuser",
            "email": "updateuser@example.com",
            "password": "password123"
        }
        
        response = requests.post(
            f"{self.BASE_URL}/users",
            json=user_data,
            headers={"Authorization": f"Bearer {auth_token}"}
        )
        user_id = response.json()["id"]
        
        # Обновление пользователя
        update_data = {
            "email": "newemail@example.com",
            "name": "Updated User"
        }
        
        response = requests.put(
            f"{self.BASE_URL}/users/{user_id}",
            json=update_data,
            headers={"Authorization": f"Bearer {auth_token}"}
        )
        
        # Проверка ответа
        assert response.status_code == 200
        data = response.json()
        assert data["id"] == user_id
        assert data["email"] == update_data["email"]
        assert data["name"] == update_data["name"]
        
        # Проверка, что пользователь был обновлен
        response = requests.get(
            f"{self.BASE_URL}/users/{user_id}",
            headers={"Authorization": f"Bearer {auth_token}"}
        )
        assert response.status_code == 200
        assert response.json()["email"] == update_data["email"]
    
    def test_delete_user(self, auth_token):
        """Тест для удаления пользователя."""
        # Создание пользователя
        user_data = {
            "username": "deleteuser",
            "email": "deleteuser@example.com",
            "password": "password123"
        }
        
        response = requests.post(
            f"{self.BASE_URL}/users",
            json=user_data,
            headers={"Authorization": f"Bearer {auth_token}"}
        )
        user_id = response.json()["id"]
        
        # Удаление пользователя
        response = requests.delete(
            f"{self.BASE_URL}/users/{user_id}",
            headers={"Authorization": f"Bearer {auth_token}"}
        )
        
        # Проверка ответа
        assert response.status_code == 204
        
        # Проверка, что пользователь был удален
        response = requests.get(
            f"{self.BASE_URL}/users/{user_id}",
            headers={"Authorization": f"Bearer {auth_token}"}
        )
        assert response.status_code == 404
```

### Тестирование с использованием BDD (Behavior-Driven Development)

```python
# features/login.feature
Feature: User Login
  As a registered user
  I want to log in to the system
  So that I can access my account

  Scenario: Successful login
    Given I am on the login page
    When I enter "testuser" as username
    And I enter "password123" as password
    And I click the login button
    Then I should be redirected to the dashboard
    And I should see "Welcome, testuser" message

  Scenario: Failed login
    Given I am on the login page
    When I enter "testuser" as username
    And I enter "wrongpassword" as password
    And I click the login button
    Then I should see "Invalid username or password" error message
```

```python
# steps/login_steps.py
from behave import given, when, then
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

@given('I am on the login page')
def step_impl(context):
    context.driver = webdriver.Chrome()
    context.driver.get("http://localhost:8000/login")

@when('I enter "{username}" as username')
def step_impl(context, username):
    context.driver.find_element(By.ID, "username").send_keys(username)

@when('I enter "{password}" as password')
def step_impl(context, password):
    context.driver.find_element(By.ID, "password").send_keys(password)

@when('I click the login button')
def step_impl(context):
    context.driver.find_element(By.ID, "login-button").click()

@then('I should be redirected to the dashboard')
def step_impl(context):
    WebDriverWait(context.driver, 10).until(
        EC.url_contains("/dashboard")
    )

@then('I should see "{message}" message')
def step_impl(context, message):
    welcome_message = context.driver.find_element(By.ID, "welcome-message")
    assert message in welcome_message.text

@then('I should see "{message}" error message')
def step_impl(context, message):
    error_message = context.driver.find_element(By.CLASS_NAME, "alert-danger")
    assert message in error_message.text
```

## Тестирование пользовательских сценариев

### Тестирование полного пользовательского сценария

```python
import pytest
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

@pytest.fixture
def driver():
    """Фикстура для создания драйвера Selenium."""
    options = webdriver.ChromeOptions()
    options.add_argument("--headless")
    driver = webdriver.Chrome(options=options)
    driver.implicitly_wait(10)
    yield driver
    driver.quit()

def test_e2e_shopping_flow(driver):
    """Функциональный тест для полного сценария покупки."""
    # 1. Регистрация пользователя
    driver.get("http://localhost:8000/register")
    driver.find_element(By.ID, "username").send_keys("customer1")
    driver.find_element(By.ID, "email").send_keys("customer1@example.com")
    driver.find_element(By.ID, "password").send_keys("password123")
    driver.find_element(By.ID, "confirm_password").send_keys("password123")
    driver.find_element(By.ID, "register-button").click()
    
    # 2. Вход в систему
    WebDriverWait(driver, 10).until(EC.url_contains("/login"))
    driver.find_element(By.ID, "username").send_keys("customer1")
    driver.find_element(By.ID, "password").send_keys("password123")
    driver.find_element(By.ID, "login-button").click()
    
    # 3. Просмотр каталога товаров
    WebDriverWait(driver, 10).until(EC.url_contains("/dashboard"))
    driver.find_element(By.ID, "catalog-link").click()
    WebDriverWait(driver, 10).until(EC.url_contains("/catalog"))
    
    # 4. Добавление товара в корзину
    driver.find_element(By.CSS_SELECTOR, ".product-item:first-child .add-to-cart").click()
    
    # 5. Проверка корзины
    driver.find_element(By.ID, "cart-link").click()
    WebDriverWait(driver, 10).until(EC.url_contains("/cart"))
    
    # Проверка, что товар добавлен в корзину
    cart_items = driver.find_elements(By.CLASS_NAME, "cart-item")
    assert len(cart_items) == 1
    
    # 6. Оформление заказа
    driver.find_element(By.ID, "checkout-button").click()
    WebDriverWait(driver, 10).until(EC.url_contains("/checkout"))
    
    # Заполнение формы доставки
    driver.find_element(By.ID, "address").send_keys("123 Main St")
    driver.find_element(By.ID, "city").send_keys("New York")
    driver.find_element(By.ID, "zip").send_keys("10001")
    driver.find_element(By.ID, "country").send_keys("USA")
    
    # 7. Выбор способа оплаты
    driver.find_element(By.ID, "payment-method-credit-card").click()
    
    # Заполнение данных карты
    driver.find_element(By.ID, "card-number").send_keys("4111111111111111")
    driver.find_element(By.ID, "card-expiry").send_keys("12/25")
    driver.find_element(By.ID, "card-cvv").send_keys("123")
    
    # 8. Подтверждение заказа
    driver.find_element(By.ID, "place-order-button").click()
    
    # 9. Проверка подтверждения заказа
    WebDriverWait(driver, 10).until(EC.url_contains("/order-confirmation"))
    
    # Проверка наличия номера заказа
    order_number = driver.find_element(By.ID, "order-number").text
    assert order_number.startswith("ORD-")
    
    # 10. Проверка истории заказов
    driver.find_element(By.ID, "orders-link").click()
    WebDriverWait(driver, 10).until(EC.url_contains("/orders"))
    
    # Проверка, что заказ отображается в истории
    order_items = driver.find_elements(By.CLASS_NAME, "order-item")
    assert len(order_items) == 1
    assert order_number in order_items[0].text
```

## Лучшие практики

### 1. Использование явных ожиданий

```python
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

# Неправильно: использование неявных ожиданий или sleep
def test_login_implicit_wait(driver):
    driver.get("http://localhost:8000/login")
    driver.find_element(By.ID, "username").send_keys("testuser")
    driver.find_element(By.ID, "password").send_keys("password123")
    driver.find_element(By.ID, "login-button").click()
    
    # Неявное ожидание
    driver.implicitly_wait(10)
    
    # или использование sleep
    import time
    time.sleep(5)
    
    welcome_message = driver.find_element(By.ID, "welcome-message")
    assert "Welcome, testuser" in welcome_message.text

# Правильно: использование явных ожиданий
def test_login_explicit_wait(driver):
    driver.get("http://localhost:8000/login")
    driver.find_element(By.ID, "username").send_keys("testuser")
    driver.find_element(By.ID, "password").send_keys("password123")
    driver.find_element(By.ID, "login-button").click()
    
    # Явное ожидание
    welcome_message = WebDriverWait(driver, 10).until(
        EC.presence_of_element_located((By.ID, "welcome-message"))
    )
    
    assert "Welcome, testuser" in welcome_message.text
```

### 2. Использование фикстур для настройки и очистки

```python
import pytest
from selenium import webdriver

# Неправильно: повторение кода настройки и очистки
def test_login_without_fixture():
    driver = webdriver.Chrome()
    try:
        # Тестирование...
        pass
    finally:
        driver.quit()

def test_registration_without_fixture():
    driver = webdriver.Chrome()
    try:
        # Тестирование...
        pass
    finally:
        driver.quit()

# Правильно: использование фикстуры
@pytest.fixture
def driver():
    """Фикстура для создания драйвера Selenium."""
    driver = webdriver.Chrome()
    yield driver
    driver.quit()

def test_login_with_fixture(driver):
    # Тестирование...
    pass

def test_registration_with_fixture(driver):
    # Тестирование...
    pass
```

### 3. Использование параметризованных тестов

```python
import pytest
from selenium import webdriver
from selenium.webdriver.common.by import By

@pytest.fixture
def driver():
    driver = webdriver.Chrome()
    yield driver
    driver.quit()

@pytest.mark.parametrize("username,password,expected_message", [
    ("testuser", "password123", "Welcome, testuser"),
    ("admin", "admin123", "Welcome, admin"),
    ("guest", "guest123", "Welcome, guest")
])
def test_login_parametrized(driver, username, password, expected_message):
    """Параметризованный тест для входа в систему."""
    driver.get("http://localhost:8000/login")
    driver.find_element(By.ID, "username").send_keys(username)
    driver.find_element(By.ID, "password").send_keys(password)
    driver.find_element(By.ID, "login-button").click()
    
    welcome_message = WebDriverWait(driver, 10).until(
        EC.presence_of_element_located((By.ID, "welcome-message"))
    )
    
    assert expected_message in welcome_message.text
```

### 4. Использование скриншотов для отладки

```python
import pytest
import os
from selenium import webdriver
from datetime import datetime

@pytest.fixture
def driver(request):
    """Фикстура для создания драйвера Selenium с поддержкой скриншотов."""
    driver = webdriver.Chrome()
    
    # Добавление метода для создания скриншотов
    def take_screenshot(name=None):
        screenshots_dir = os.path.join(os.path.dirname(__file__), "screenshots")
        os.makedirs(screenshots_dir, exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
        test_name = request.node.name
        name = name or f"{test_name}_{timestamp}"
        
        screenshot_path = os.path.join(screenshots_dir, f"{name}.png")
        driver.save_screenshot(screenshot_path)
        return screenshot_path
    
    driver.take_screenshot = take_screenshot
    
    yield driver
    
    # Создание скриншота при ошибке
    if request.node.rep_call.failed:
        driver.take_screenshot(f"{request.node.name}_failed")
    
    driver.quit()

# Хук для сохранения результата теста
@pytest.hookimpl(tryfirst=True, hookwrapper=True)
def pytest_runtest_makereport(item, call):
    outcome = yield
    rep = outcome.get_result()
    setattr(item, f"rep_{rep.when}", rep)

def test_with_screenshot(driver):
    """Тест с поддержкой скриншотов."""
    driver.get("http://localhost:8000/login")
    
    # Создание скриншота в процессе теста
    driver.take_screenshot("login_page")
    
    # Продолжение теста...
    assert True
```

### 5. Использование пользовательских ожиданий

```python
from selenium import webdriver
from selenium.webdriver.support.ui import WebDriverWait
from selenium.common.exceptions import TimeoutException

def wait_for_ajax(driver, timeout=10):
    """Пользовательское ожидание завершения AJAX-запросов."""
    def ajax_complete(driver):
        return driver.execute_script("return jQuery.active == 0")
    
    try:
        WebDriverWait(driver, timeout).until(ajax_complete)
        return True
    except TimeoutException:
        return False

def test_with_ajax(driver):
    """Тест с ожиданием завершения AJAX-запросов."""
    driver.get("http://localhost:8000/products")
    
    # Клик по кнопке, которая запускает AJAX-запрос
    driver.find_element(By.ID, "load-more-button").click()
    
    # Ожидание завершения AJAX-запроса
    wait_for_ajax(driver)
    
    # Проверка результатов
    products = driver.find_elements(By.CLASS_NAME, "product-item")
    assert len(products) > 10
```

## Интеграция с другими правилами

- **Принципы тестирования**: Основные принципы тестирования описаны в @python-testing-principles.mdc
- **Модульное тестирование**: Подробные рекомендации по написанию модульных тестов описаны в @python-unit-testing.mdc
- **Интеграционное тестирование**: Рекомендации по написанию интеграционных тестов описаны в @python-integration-testing.mdc 