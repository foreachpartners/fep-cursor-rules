---
description: Правила написания интеграционных тестов для Python приложений
globs: "test_*.py,*_test.py,tests/*.py,conftest.py"
alwaysApply: true
related: ["python-testing-principles.mdc", "python-unit-testing.mdc", "python-testing-fixtures.mdc"]
priority: 7
---
# Правила интеграционного тестирования в Python

Рекомендации по написанию интеграционных тестов для Python приложений. Интеграционные тесты проверяют взаимодействие между компонентами системы и их интеграцию с внешними сервисами.

---

## Основные принципы интеграционного тестирования

1. **Проверка взаимодействия компонентов**: Интеграционные тесты проверяют, что компоненты системы правильно взаимодействуют друг с другом.
2. **Тестирование реальных зависимостей**: В отличие от модульных тестов, интеграционные тесты часто используют реальные зависимости вместо моков.
3. **Изоляция тестовой среды**: Тесты должны выполняться в изолированной среде, чтобы не влиять на реальные данные.
4. **Идемпотентность**: Тесты должны быть идемпотентными, то есть их можно запускать многократно без изменения результата.
5. **Независимость**: Тесты должны быть независимыми друг от друга и выполняться в любом порядке.

## Структура интеграционных тестов

### Тестирование взаимодействия компонентов

```python
import pytest
from myapp.services import UserService
from myapp.repositories import UserRepository
from myapp.database import Database

@pytest.fixture
def database():
    """Фикстура для создания тестовой базы данных."""
    db = Database("sqlite:///:memory:")
    db.create_tables()
    yield db
    db.close()

@pytest.fixture
def user_repository(database):
    """Фикстура для создания репозитория пользователей."""
    return UserRepository(database)

@pytest.fixture
def user_service(user_repository):
    """Фикстура для создания сервиса пользователей."""
    return UserService(user_repository)

def test_create_and_get_user(user_service):
    """Интеграционный тест для создания и получения пользователя."""
    # Создание пользователя
    user_id = user_service.create_user("John", "john@example.com", 30)
    
    # Получение пользователя
    user = user_service.get_user(user_id)
    
    # Проверка
    assert user.name == "John"
    assert user.email == "john@example.com"
    assert user.age == 30
```

### Тестирование API

```python
import pytest
from fastapi.testclient import TestClient
from myapp.main import app
from myapp.database import Database

@pytest.fixture
def client():
    """Фикстура для создания тестового клиента FastAPI."""
    # Настройка тестовой базы данных
    app.dependency_overrides[get_db] = lambda: Database("sqlite:///:memory:")
    
    # Создание тестового клиента
    client = TestClient(app)
    
    yield client
    
    # Очистка
    app.dependency_overrides.clear()

def test_create_user(client):
    """Интеграционный тест для создания пользователя через API."""
    # Отправка запроса
    response = client.post(
        "/users/",
        json={"name": "John", "email": "john@example.com", "age": 30}
    )
    
    # Проверка ответа
    assert response.status_code == 201
    data = response.json()
    assert "id" in data
    assert data["name"] == "John"
    assert data["email"] == "john@example.com"
    assert data["age"] == 30
    
    # Проверка, что пользователь был создан
    user_id = data["id"]
    response = client.get(f"/users/{user_id}")
    assert response.status_code == 200
    assert response.json()["id"] == user_id
```

### Тестирование базы данных

```python
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from myapp.models import Base, User

@pytest.fixture
def db_session():
    """Фикстура для создания сессии базы данных."""
    # Создание тестовой базы данных в памяти
    engine = create_engine("sqlite:///:memory:")
    Base.metadata.create_all(engine)
    
    # Создание сессии
    Session = sessionmaker(bind=engine)
    session = Session()
    
    yield session
    
    # Очистка
    session.close()
    Base.metadata.drop_all(engine)

def test_create_and_query_user(db_session):
    """Интеграционный тест для создания и запроса пользователя в базе данных."""
    # Создание пользователя
    user = User(name="John", email="john@example.com", age=30)
    db_session.add(user)
    db_session.commit()
    
    # Запрос пользователя
    queried_user = db_session.query(User).filter_by(email="john@example.com").first()
    
    # Проверка
    assert queried_user is not None
    assert queried_user.name == "John"
    assert queried_user.email == "john@example.com"
    assert queried_user.age == 30
```

## Тестирование внешних сервисов

### Использование тестовых контейнеров

```python
import pytest
import psycopg2
from testcontainers.postgres import PostgresContainer

@pytest.fixture
def postgres_container():
    """Фикстура для создания контейнера PostgreSQL."""
    container = PostgresContainer("postgres:13")
    container.start()
    yield container
    container.stop()

def test_postgres_connection(postgres_container):
    """Интеграционный тест для подключения к PostgreSQL."""
    # Получение параметров подключения
    connection_url = postgres_container.get_connection_url()
    
    # Подключение к базе данных
    conn = psycopg2.connect(connection_url)
    cursor = conn.cursor()
    
    # Выполнение запроса
    cursor.execute("SELECT 1")
    result = cursor.fetchone()
    
    # Проверка
    assert result[0] == 1
    
    # Очистка
    cursor.close()
    conn.close()
```

### Использование моков для внешних API

```python
import pytest
import requests
import responses
from myapp.services import WeatherService

@responses.activate
def test_weather_service():
    """Интеграционный тест для сервиса погоды с моком внешнего API."""
    # Настройка мока для внешнего API
    responses.add(
        responses.GET,
        "https://api.weather.com/current?city=London",
        json={"temperature": 20, "humidity": 70},
        status=200
    )
    
    # Создание сервиса
    service = WeatherService(api_key="test_key")
    
    # Получение погоды
    weather = service.get_current_weather("London")
    
    # Проверка
    assert weather["temperature"] == 20
    assert weather["humidity"] == 70
```

### Использование реальных внешних сервисов

```python
import pytest
import os
from myapp.services import EmailService

@pytest.mark.external
def test_send_email():
    """Интеграционный тест для отправки реального email."""
    # Пропуск теста, если нет переменных окружения
    if "EMAIL_API_KEY" not in os.environ:
        pytest.skip("EMAIL_API_KEY not set")
    
    # Создание сервиса
    service = EmailService(api_key=os.environ["EMAIL_API_KEY"])
    
    # Отправка email
    result = service.send(
        to="test@example.com",
        subject="Test Email",
        body="This is a test email"
    )
    
    # Проверка
    assert result.success is True
    assert result.message_id is not None
```

## Тестирование асинхронного кода

### Асинхронные тесты с pytest-asyncio

```python
import pytest
import asyncio
from myapp.services import AsyncUserService

@pytest.fixture
async def async_user_service():
    """Асинхронная фикстура для создания сервиса пользователей."""
    service = AsyncUserService()
    await service.connect()
    yield service
    await service.disconnect()

@pytest.mark.asyncio
async def test_create_user(async_user_service):
    """Асинхронный интеграционный тест для создания пользователя."""
    # Создание пользователя
    user_id = await async_user_service.create_user("John", "john@example.com")
    
    # Получение пользователя
    user = await async_user_service.get_user(user_id)
    
    # Проверка
    assert user.name == "John"
    assert user.email == "john@example.com"
```

### Тестирование асинхронного API

```python
import pytest
import httpx
from myapp.main import app

@pytest.fixture
async def async_client():
    """Фикстура для создания асинхронного тестового клиента."""
    async with httpx.AsyncClient(app=app, base_url="http://testserver") as client:
        yield client

@pytest.mark.asyncio
async def test_create_user(async_client):
    """Асинхронный интеграционный тест для создания пользователя через API."""
    # Отправка запроса
    response = await async_client.post(
        "/users/",
        json={"name": "John", "email": "john@example.com"}
    )
    
    # Проверка ответа
    assert response.status_code == 201
    data = response.json()
    assert "id" in data
    assert data["name"] == "John"
    assert data["email"] == "john@example.com"
```

## Тестирование веб-приложений

### Тестирование с Selenium

```python
import pytest
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.options import Options

@pytest.fixture
def driver():
    """Фикстура для создания драйвера Selenium."""
    # Настройка опций Chrome
    chrome_options = Options()
    chrome_options.add_argument("--headless")
    chrome_options.add_argument("--no-sandbox")
    
    # Создание драйвера
    driver = webdriver.Chrome(options=chrome_options)
    
    yield driver
    
    # Закрытие драйвера
    driver.quit()

def test_login_page(driver):
    """Интеграционный тест для страницы входа."""
    # Открытие страницы
    driver.get("http://localhost:8000/login")
    
    # Заполнение формы
    driver.find_element(By.ID, "username").send_keys("testuser")
    driver.find_element(By.ID, "password").send_keys("password")
    driver.find_element(By.ID, "login-button").click()
    
    # Проверка, что пользователь вошел в систему
    assert "Welcome, testuser" in driver.page_source
```

### Тестирование с pytest-django

```python
import pytest
from django.urls import reverse
from myapp.models import User

@pytest.mark.django_db
def test_user_list_view(client):
    """Интеграционный тест для представления списка пользователей."""
    # Создание пользователей
    User.objects.create(username="user1", email="user1@example.com")
    User.objects.create(username="user2", email="user2@example.com")
    
    # Получение страницы
    url = reverse("user-list")
    response = client.get(url)
    
    # Проверка
    assert response.status_code == 200
    assert "user1" in response.content.decode()
    assert "user2" in response.content.decode()
```

## Лучшие практики

### 1. Изоляция тестовой среды

```python
import pytest
import os
import tempfile

@pytest.fixture
def isolated_environment():
    """Фикстура для создания изолированной среды."""
    # Сохранение текущих переменных окружения
    original_env = os.environ.copy()
    
    # Создание временной директории
    temp_dir = tempfile.mkdtemp()
    os.environ["APP_DATA_DIR"] = temp_dir
    
    yield
    
    # Восстановление переменных окружения
    os.environ.clear()
    os.environ.update(original_env)
    
    # Удаление временной директории
    import shutil
    shutil.rmtree(temp_dir)

def test_with_isolated_environment(isolated_environment):
    """Тест, использующий изолированную среду."""
    # Тест будет использовать временную директорию
    assert os.environ["APP_DATA_DIR"] != "/"
    
    # Выполнение теста...
```

### 2. Использование тестовых данных

```python
import pytest
import json
import os

@pytest.fixture
def test_data():
    """Фикстура для загрузки тестовых данных."""
    # Путь к файлу с тестовыми данными
    data_file = os.path.join(os.path.dirname(__file__), "data", "test_data.json")
    
    # Загрузка данных
    with open(data_file, "r") as f:
        data = json.load(f)
    
    return data

def test_with_test_data(test_data, db_session):
    """Тест, использующий тестовые данные."""
    # Создание пользователей из тестовых данных
    for user_data in test_data["users"]:
        user = User(**user_data)
        db_session.add(user)
    db_session.commit()
    
    # Проверка, что пользователи были созданы
    users = db_session.query(User).all()
    assert len(users) == len(test_data["users"])
```

### 3. Использование фабрик для создания тестовых объектов

```python
import pytest
import factory
from myapp.models import User, Post

class UserFactory(factory.Factory):
    """Фабрика для создания пользователей."""
    class Meta:
        model = User
    
    name = factory.Sequence(lambda n: f"user{n}")
    email = factory.LazyAttribute(lambda o: f"{o.name}@example.com")
    age = factory.Faker("random_int", min=18, max=90)

class PostFactory(factory.Factory):
    """Фабрика для создания постов."""
    class Meta:
        model = Post
    
    title = factory.Faker("sentence")
    content = factory.Faker("paragraph")
    author = factory.SubFactory(UserFactory)

def test_with_factories(db_session):
    """Тест, использующий фабрики для создания объектов."""
    # Создание пользователя
    user = UserFactory()
    db_session.add(user)
    db_session.commit()
    
    # Создание постов
    posts = PostFactory.create_batch(5, author=user)
    for post in posts:
        db_session.add(post)
    db_session.commit()
    
    # Проверка
    assert db_session.query(User).count() == 1
    assert db_session.query(Post).count() == 5
    assert all(post.author.id == user.id for post in posts)
```

### 4. Маркировка тестов

```python
import pytest

@pytest.mark.slow
def test_slow_operation():
    """Медленный интеграционный тест."""
    # Медленная операция...
    import time
    time.sleep(2)
    assert True

@pytest.mark.database
def test_database_operation(db_session):
    """Тест, работающий с базой данных."""
    # Операции с базой данных...
    assert db_session.query(User).count() == 0

@pytest.mark.external
def test_external_service():
    """Тест, использующий внешний сервис."""
    # Операции с внешним сервисом...
    assert True
```

### 5. Параллельное выполнение тестов

```python
# pytest.ini
[pytest]
addopts = -n auto
markers =
    slow: marks tests as slow
    database: marks tests that use the database
    external: marks tests that use external services
```

```python
# conftest.py
def pytest_configure(config):
    """Настройка pytest."""
    config.addinivalue_line("markers", "slow: marks tests as slow")
    config.addinivalue_line("markers", "database: marks tests that use the database")
    config.addinivalue_line("markers", "external: marks tests that use external services")
```

## Интеграция с другими правилами

- **Принципы тестирования**: Основные принципы тестирования описаны в @python-testing-principles.mdc
- **Модульное тестирование**: Подробные рекомендации по написанию модульных тестов описаны в @python-unit-testing.mdc
- **Фикстуры и моки**: Рекомендации по использованию фикстур и моков описаны в @python-testing-fixtures.mdc 