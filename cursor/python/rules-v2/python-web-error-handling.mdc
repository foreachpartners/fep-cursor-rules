---
description: Правила обработки ошибок в веб-приложениях на Python
globs: "*.py"
alwaysApply: false
related: ["python-error-handling-principles.mdc", "python-layered-architecture.mdc"]
priority: 7
---
# Обработка ошибок в веб-приложениях на Python

Рекомендации по обработке ошибок и исключений в веб-приложениях на Python. Правильная обработка ошибок в веб-приложениях обеспечивает хороший пользовательский опыт, безопасность и удобство отладки.

---

## Основные принципы обработки ошибок в веб-приложениях

1. **Согласованность**: Используйте согласованный формат ответов об ошибках.
2. **Информативность**: Предоставляйте полезную информацию об ошибке клиенту.
3. **Безопасность**: Не раскрывайте чувствительную информацию в сообщениях об ошибках.
4. **Логирование**: Логируйте все ошибки с достаточным контекстом для отладки.
5. **HTTP-статусы**: Используйте правильные HTTP-статусы для разных типов ошибок.
6. **Централизация**: Обрабатывайте ошибки централизованно с помощью обработчиков исключений.

## Обработка ошибок в различных веб-фреймворках

### Flask

#### Глобальный обработчик ошибок

```python
from flask import Flask, jsonify, request
import logging

app = Flask(__name__)
logger = logging.getLogger(__name__)

class APIError(Exception):
    """Базовый класс для API-ошибок."""
    status_code = 500
    
    def __init__(self, message, status_code=None, payload=None):
        super().__init__(message)
        self.message = message
        if status_code is not None:
            self.status_code = status_code
        self.payload = payload
    
    def to_dict(self):
        rv = dict(self.payload or ())
        rv['message'] = self.message
        rv['status'] = 'error'
        return rv

class ResourceNotFoundError(APIError):
    """Ресурс не найден."""
    status_code = 404

class ValidationError(APIError):
    """Ошибка валидации."""
    status_code = 400

@app.errorhandler(APIError)
def handle_api_error(error):
    """Обработчик API-ошибок."""
    response = jsonify(error.to_dict())
    response.status_code = error.status_code
    return response

@app.errorhandler(404)
def handle_not_found(error):
    """Обработчик ошибки 404."""
    return jsonify({
        'status': 'error',
        'message': 'Resource not found'
    }), 404

@app.errorhandler(500)
def handle_server_error(error):
    """Обработчик ошибки 500."""
    logger.exception("Unhandled exception: %s", str(error))
    return jsonify({
        'status': 'error',
        'message': 'Internal server error'
    }), 500

@app.route('/users/<int:user_id>')
def get_user(user_id):
    user = find_user(user_id)
    if not user:
        raise ResourceNotFoundError(f"User with ID {user_id} not found")
    return jsonify(user)

@app.route('/users', methods=['POST'])
def create_user():
    data = request.get_json()
    
    # Валидация данных
    errors = validate_user_data(data)
    if errors:
        raise ValidationError("Invalid user data", payload={'errors': errors})
    
    # Создание пользователя
    user = create_user_in_db(data)
    return jsonify(user), 201
```

#### Использование декораторов для обработки ошибок

```python
import functools
from flask import jsonify

def handle_exceptions(func):
    """Декоратор для обработки исключений в маршрутах."""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except ResourceNotFoundError as e:
            logger.warning(f"Resource not found: {e}")
            return jsonify({
                'status': 'error',
                'message': str(e)
            }), 404
        except ValidationError as e:
            logger.warning(f"Validation error: {e}")
            return jsonify({
                'status': 'error',
                'message': str(e),
                'errors': e.payload.get('errors', {})
            }), 400
        except Exception as e:
            logger.exception(f"Unexpected error in {func.__name__}: {e}")
            return jsonify({
                'status': 'error',
                'message': 'Internal server error'
            }), 500
    return wrapper

@app.route('/products/<int:product_id>')
@handle_exceptions
def get_product(product_id):
    product = find_product(product_id)
    if not product:
        raise ResourceNotFoundError(f"Product with ID {product_id} not found")
    return jsonify(product)
```

### FastAPI

#### Глобальные обработчики исключений

```python
from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from pydantic import BaseModel
import logging

app = FastAPI()
logger = logging.getLogger(__name__)

class ErrorResponse(BaseModel):
    """Модель ответа с ошибкой."""
    status: str = "error"
    message: str
    details: dict = None

@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    """Обработчик HTTP-исключений."""
    return JSONResponse(
        status_code=exc.status_code,
        content=ErrorResponse(
            message=exc.detail,
            details=exc.headers
        ).dict()
    )

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """Обработчик ошибок валидации."""
    errors = {}
    for error in exc.errors():
        location = error["loc"]
        field = location[-1] if len(location) > 1 else location[0]
        errors[field] = error["msg"]
    
    return JSONResponse(
        status_code=422,
        content=ErrorResponse(
            message="Validation error",
            details={"errors": errors}
        ).dict()
    )

@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    """Обработчик всех остальных исключений."""
    logger.exception(f"Unhandled exception: {exc}")
    return JSONResponse(
        status_code=500,
        content=ErrorResponse(
            message="Internal server error"
        ).dict()
    )

# Пользовательские исключения
class NotFoundError(HTTPException):
    """Ресурс не найден."""
    def __init__(self, detail: str):
        super().__init__(status_code=404, detail=detail)

class ValidationError(HTTPException):
    """Ошибка валидации."""
    def __init__(self, detail: str, errors: dict = None):
        super().__init__(
            status_code=400,
            detail=detail,
            headers={"X-Validation-Errors": str(errors)} if errors else None
        )

# Использование
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    user = find_user(user_id)
    if not user:
        raise NotFoundError(f"User with ID {user_id} not found")
    return user
```

### Django REST Framework

#### Настройка обработки исключений

```python
# exceptions.py
from rest_framework.views import exception_handler
from rest_framework.exceptions import APIException
from rest_framework import status
from rest_framework.response import Response
import logging

logger = logging.getLogger(__name__)

class ServiceUnavailableError(APIException):
    """Сервис недоступен."""
    status_code = status.HTTP_503_SERVICE_UNAVAILABLE
    default_detail = "Service temporarily unavailable"
    default_code = "service_unavailable"

class ResourceNotFoundError(APIException):
    """Ресурс не найден."""
    status_code = status.HTTP_404_NOT_FOUND
    default_detail = "Resource not found"
    default_code = "not_found"

class ValidationError(APIException):
    """Ошибка валидации."""
    status_code = status.HTTP_400_BAD_REQUEST
    default_detail = "Invalid data"
    default_code = "invalid"

def custom_exception_handler(exc, context):
    """Пользовательский обработчик исключений."""
    # Сначала вызываем стандартный обработчик
    response = exception_handler(exc, context)
    
    # Если это необработанное исключение
    if response is None:
        logger.exception(f"Unhandled exception: {exc}")
        return Response(
            {"status": "error", "message": "Internal server error"},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )
    
    # Форматирование ответа
    if not isinstance(response.data, dict):
        response.data = {"status": "error", "message": str(response.data)}
    elif "detail" in response.data:
        response.data = {
            "status": "error",
            "message": response.data["detail"],
            "code": response.data.get("code", "error")
        }
    else:
        response.data = {
            "status": "error",
            "message": "Validation error",
            "errors": response.data
        }
    
    return response

# settings.py
REST_FRAMEWORK = {
    'EXCEPTION_HANDLER': 'myapp.exceptions.custom_exception_handler',
    # ...
}

# views.py
from rest_framework.views import APIView
from rest_framework.response import Response
from .exceptions import ResourceNotFoundError, ValidationError

class UserView(APIView):
    def get(self, request, user_id):
        try:
            user = find_user(user_id)
            if not user:
                raise ResourceNotFoundError(f"User with ID {user_id} not found")
            return Response(user)
        except DatabaseError as e:
            logger.error(f"Database error: {e}")
            raise ServiceUnavailableError("Database error")
```

## Обработка ошибок в API

### Структура ответа с ошибкой

```json
{
  "status": "error",
  "message": "Validation error",
  "code": "invalid_data",
  "errors": {
    "email": "Invalid email format",
    "password": "Password must be at least 8 characters long"
  },
  "request_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

### HTTP-статусы для разных типов ошибок

- **400 Bad Request**: Ошибки валидации, неправильный формат запроса
- **401 Unauthorized**: Отсутствие аутентификации
- **403 Forbidden**: Недостаточно прав доступа
- **404 Not Found**: Ресурс не найден
- **409 Conflict**: Конфликт (например, дублирование уникального ключа)
- **422 Unprocessable Entity**: Семантические ошибки в запросе
- **429 Too Many Requests**: Превышение лимита запросов
- **500 Internal Server Error**: Внутренняя ошибка сервера
- **503 Service Unavailable**: Сервис временно недоступен

### Обработка ошибок в асинхронных API

```python
import asyncio
from fastapi import FastAPI, HTTPException, BackgroundTasks
import logging

app = FastAPI()
logger = logging.getLogger(__name__)

async def process_async_task(task_id: str):
    """Асинхронная задача с обработкой ошибок."""
    try:
        # Выполнение задачи
        result = await perform_long_running_task(task_id)
        # Сохранение результата
        await save_task_result(task_id, result)
    except Exception as e:
        logger.exception(f"Error processing task {task_id}: {e}")
        # Сохранение информации об ошибке
        await save_task_error(task_id, str(e))

@app.post("/tasks")
async def create_task(background_tasks: BackgroundTasks):
    """Создание асинхронной задачи."""
    task_id = generate_task_id()
    
    # Запуск задачи в фоне
    background_tasks.add_task(process_async_task, task_id)
    
    return {"task_id": task_id, "status": "processing"}

@app.get("/tasks/{task_id}")
async def get_task_status(task_id: str):
    """Получение статуса задачи."""
    task = await get_task(task_id)
    if not task:
        raise HTTPException(status_code=404, detail=f"Task {task_id} not found")
    
    if task["status"] == "error":
        return {
            "task_id": task_id,
            "status": "error",
            "error": task["error"]
        }
    
    return {
        "task_id": task_id,
        "status": task["status"],
        "result": task.get("result")
    }
```

## Лучшие практики

### 1. Используйте иерархию исключений для API

```python
class APIError(Exception):
    """Базовый класс для всех API-ошибок."""
    status_code = 500
    error_code = "internal_error"
    
    def __init__(self, message, error_code=None, status_code=None, details=None):
        super().__init__(message)
        self.message = message
        self.details = details
        
        if error_code is not None:
            self.error_code = error_code
        
        if status_code is not None:
            self.status_code = status_code
    
    def to_dict(self):
        response = {
            "status": "error",
            "message": self.message,
            "code": self.error_code
        }
        
        if self.details:
            response["details"] = self.details
        
        return response

class BadRequestError(APIError):
    """Ошибка в запросе клиента."""
    status_code = 400
    error_code = "bad_request"

class AuthenticationError(APIError):
    """Ошибка аутентификации."""
    status_code = 401
    error_code = "authentication_failed"

class AuthorizationError(APIError):
    """Ошибка авторизации."""
    status_code = 403
    error_code = "forbidden"

class ResourceNotFoundError(APIError):
    """Ресурс не найден."""
    status_code = 404
    error_code = "not_found"

class ValidationError(BadRequestError):
    """Ошибка валидации."""
    error_code = "validation_error"
    
    def __init__(self, message, errors=None):
        super().__init__(message, details={"errors": errors} if errors else None)

class ConflictError(APIError):
    """Конфликт при выполнении операции."""
    status_code = 409
    error_code = "conflict"

class RateLimitError(APIError):
    """Превышение лимита запросов."""
    status_code = 429
    error_code = "rate_limit_exceeded"

class ServerError(APIError):
    """Внутренняя ошибка сервера."""
    status_code = 500
    error_code = "internal_error"

class ServiceUnavailableError(APIError):
    """Сервис временно недоступен."""
    status_code = 503
    error_code = "service_unavailable"
```

### 2. Логируйте ошибки с контекстом

```python
import logging
import uuid
from flask import request, g

logger = logging.getLogger(__name__)

@app.before_request
def before_request():
    """Добавление request_id к каждому запросу."""
    g.request_id = request.headers.get('X-Request-ID') or str(uuid.uuid4())

def log_error(error, level=logging.ERROR):
    """Логирование ошибки с контекстом."""
    request_id = getattr(g, 'request_id', 'unknown')
    user_id = getattr(g, 'user_id', 'anonymous')
    
    extra = {
        'request_id': request_id,
        'user_id': user_id,
        'method': request.method,
        'path': request.path,
        'remote_addr': request.remote_addr
    }
    
    if isinstance(error, APIError):
        logger.log(level, f"API Error: {error.message}", extra=extra)
    else:
        logger.log(level, f"Unexpected error: {str(error)}", extra=extra, exc_info=True)

@app.errorhandler(APIError)
def handle_api_error(error):
    """Обработчик API-ошибок с логированием."""
    log_error(error, logging.WARNING if error.status_code < 500 else logging.ERROR)
    
    response = jsonify(error.to_dict())
    response.status_code = error.status_code
    response.headers['X-Request-ID'] = g.request_id
    return response

@app.errorhandler(Exception)
def handle_unexpected_error(error):
    """Обработчик неожиданных ошибок с логированием."""
    log_error(error, logging.ERROR)
    
    response = jsonify({
        'status': 'error',
        'message': 'Internal server error',
        'code': 'internal_error',
        'request_id': g.request_id
    })
    response.status_code = 500
    response.headers['X-Request-ID'] = g.request_id
    return response
```

### 3. Используйте middleware для обработки ошибок

```python
# Пример для ASGI-приложения (FastAPI, Starlette)
import time
import uuid
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware
import logging

app = FastAPI()
logger = logging.getLogger(__name__)

class ErrorHandlingMiddleware(BaseHTTPMiddleware):
    """Middleware для обработки ошибок и логирования."""
    
    async def dispatch(self, request: Request, call_next):
        # Генерация request_id
        request_id = request.headers.get('X-Request-ID', str(uuid.uuid4()))
        
        # Добавление request_id в контекст запроса
        request.state.request_id = request_id
        
        # Время начала обработки запроса
        start_time = time.time()
        
        try:
            # Обработка запроса
            response = await call_next(request)
            
            # Добавление request_id в заголовки ответа
            response.headers['X-Request-ID'] = request_id
            
            # Логирование успешного запроса
            process_time = time.time() - start_time
            logger.info(
                f"Request completed: {request.method} {request.url.path}",
                extra={
                    'request_id': request_id,
                    'method': request.method,
                    'path': request.url.path,
                    'status_code': response.status_code,
                    'process_time': process_time
                }
            )
            
            return response
        
        except Exception as e:
            # Логирование ошибки
            process_time = time.time() - start_time
            logger.exception(
                f"Request failed: {request.method} {request.url.path}",
                extra={
                    'request_id': request_id,
                    'method': request.method,
                    'path': request.url.path,
                    'process_time': process_time,
                    'error': str(e)
                }
            )
            
            # Формирование ответа с ошибкой
            return JSONResponse(
                status_code=500,
                content={
                    'status': 'error',
                    'message': 'Internal server error',
                    'request_id': request_id
                },
                headers={'X-Request-ID': request_id}
            )

# Добавление middleware
app.add_middleware(ErrorHandlingMiddleware)
```

### 4. Используйте схемы валидации

```python
from pydantic import BaseModel, Field, EmailStr, validator
from fastapi import FastAPI, HTTPException
from typing import Optional

app = FastAPI()

class UserCreate(BaseModel):
    """Схема для создания пользователя."""
    username: str = Field(..., min_length=3, max_length=50)
    email: EmailStr
    password: str = Field(..., min_length=8)
    age: Optional[int] = Field(None, ge=18, le=120)
    
    @validator('username')
    def username_alphanumeric(cls, v):
        if not v.isalnum():
            raise ValueError('Username must be alphanumeric')
        return v

@app.post("/users")
async def create_user(user: UserCreate):
    try:
        # Создание пользователя
        db_user = await create_user_in_db(user.dict())
        return db_user
    except DuplicateUserError as e:
        raise HTTPException(
            status_code=409,
            detail=f"User with email {user.email} already exists"
        )
    except DatabaseError as e:
        logger.error(f"Database error: {e}")
        raise HTTPException(
            status_code=503,
            detail="Service temporarily unavailable"
        )
```

### 5. Обрабатывайте ошибки в клиентском коде

```python
import requests
from requests.exceptions import RequestException, Timeout, ConnectionError
import logging

logger = logging.getLogger(__name__)

class APIClient:
    """Клиент для работы с API."""
    
    def __init__(self, base_url, timeout=10):
        self.base_url = base_url
        self.timeout = timeout
    
    def _handle_response(self, response):
        """Обработка ответа от API."""
        try:
            response.raise_for_status()
            return response.json()
        except requests.HTTPError as e:
            # Обработка ошибок HTTP
            try:
                error_data = response.json()
                error_message = error_data.get('message', str(e))
                error_code = error_data.get('code', 'unknown')
                
                logger.error(
                    f"API error: {error_message} (code: {error_code}, status: {response.status_code})",
                    extra={
                        'status_code': response.status_code,
                        'error_code': error_code,
                        'url': response.url
                    }
                )
                
                if response.status_code == 404:
                    raise ResourceNotFoundError(error_message)
                elif response.status_code == 400:
                    raise ValidationError(error_message, error_data.get('errors'))
                elif response.status_code == 401:
                    raise AuthenticationError(error_message)
                elif response.status_code == 403:
                    raise AuthorizationError(error_message)
                elif response.status_code == 429:
                    raise RateLimitError(error_message)
                elif 500 <= response.status_code < 600:
                    raise ServerError(error_message)
                else:
                    raise APIError(error_message, status_code=response.status_code)
            
            except ValueError:
                # Ответ не в формате JSON
                logger.error(
                    f"Invalid API response: {response.text}",
                    extra={'status_code': response.status_code, 'url': response.url}
                )
                raise APIError(f"Invalid API response: {response.status_code}", status_code=response.status_code)
    
    def get(self, endpoint, params=None):
        """Выполнение GET-запроса."""
        url = f"{self.base_url}/{endpoint}"
        
        try:
            response = requests.get(url, params=params, timeout=self.timeout)
            return self._handle_response(response)
        except Timeout:
            logger.error(f"API request timeout: {url}")
            raise APIError("Request timeout", status_code=504)
        except ConnectionError:
            logger.error(f"API connection error: {url}")
            raise APIError("Connection error", status_code=503)
        except RequestException as e:
            logger.error(f"API request error: {url} - {e}")
            raise APIError(f"Request error: {e}", status_code=500)
```

## Интеграция с другими правилами

- **Принципы обработки ошибок**: Основные принципы обработки ошибок описаны в @python-error-handling-principles.mdc
- **Архитектура приложения**: Обработка ошибок должна соответствовать архитектурным принципам, описанным в @python-layered-architecture.mdc 