---
description: Правила создания и использования фикстур и моков в Python тестах
globs: "test_*.py,*_test.py,tests/*.py,conftest.py"
alwaysApply: true
related: ["python-testing-principles.mdc", "python-unit-testing.mdc", "python-dependency-injection.mdc"]
priority: 7
---
# Правила использования фикстур и моков в Python тестах

Рекомендации по созданию и использованию фикстур и моков в тестах Python. Фикстуры и моки помогают изолировать тестируемый код и сделать тесты более надежными и поддерживаемыми.

---

## Фикстуры

Фикстуры - это механизм для подготовки и очистки тестового окружения. Они позволяют повторно использовать код для настройки и очистки тестов.

### Фикстуры в pytest

#### Базовые фикстуры

```python
import pytest

@pytest.fixture
def user_data():
    """Фикстура, возвращающая тестовые данные пользователя."""
    return {
        "name": "John Doe",
        "email": "john@example.com",
        "age": 30
    }

def test_create_user(user_data):
    """Тест, использующий фикстуру user_data."""
    user = create_user(user_data["name"], user_data["email"], user_data["age"])
    assert user.name == user_data["name"]
    assert user.email == user_data["email"]
    assert user.age == user_data["age"]
```

#### Фикстуры с настройкой и очисткой

```python
import pytest
import os
import tempfile

@pytest.fixture
def temp_file():
    """Фикстура, создающая временный файл и удаляющая его после теста."""
    # Настройка (setup)
    fd, path = tempfile.mkstemp()
    
    # Предоставление значения фикстуры
    yield path
    
    # Очистка (teardown)
    os.close(fd)
    os.unlink(path)

def test_write_to_file(temp_file):
    """Тест, использующий фикстуру temp_file."""
    data = "Hello, World!"
    write_to_file(temp_file, data)
    
    with open(temp_file, 'r') as f:
        content = f.read()
    
    assert content == data
```

#### Параметризованные фикстуры

```python
import pytest

@pytest.fixture(params=["sqlite", "mysql", "postgresql"])
def database_type(request):
    """Параметризованная фикстура, предоставляющая разные типы баз данных."""
    return request.param

def test_database_connection(database_type):
    """Тест, запускаемый для каждого параметра фикстуры database_type."""
    connection = create_connection(database_type)
    assert connection.is_connected()
    connection.close()
```

#### Фикстуры с областью видимости

```python
import pytest

@pytest.fixture(scope="function")
def function_fixture():
    """Фикстура с областью видимости 'function' (по умолчанию)."""
    print("\nSetting up function fixture")
    yield
    print("\nTearing down function fixture")

@pytest.fixture(scope="class")
def class_fixture():
    """Фикстура с областью видимости 'class'."""
    print("\nSetting up class fixture")
    yield
    print("\nTearing down class fixture")

@pytest.fixture(scope="module")
def module_fixture():
    """Фикстура с областью видимости 'module'."""
    print("\nSetting up module fixture")
    yield
    print("\nTearing down module fixture")

@pytest.fixture(scope="session")
def session_fixture():
    """Фикстура с областью видимости 'session'."""
    print("\nSetting up session fixture")
    yield
    print("\nTearing down session fixture")

def test_1(function_fixture, module_fixture, session_fixture):
    print("Running test_1")

def test_2(function_fixture, module_fixture, session_fixture):
    print("Running test_2")
```

### Фикстуры в unittest

```python
import unittest
import tempfile
import os

class TestFile(unittest.TestCase):
    def setUp(self):
        """Метод, вызываемый перед каждым тестом."""
        self.fd, self.path = tempfile.mkstemp()
    
    def tearDown(self):
        """Метод, вызываемый после каждого теста."""
        os.close(self.fd)
        os.unlink(self.path)
    
    def test_write_to_file(self):
        """Тест, использующий self.path из setUp."""
        data = "Hello, World!"
        write_to_file(self.path, data)
        
        with open(self.path, 'r') as f:
            content = f.read()
        
        self.assertEqual(content, data)
    
    @classmethod
    def setUpClass(cls):
        """Метод, вызываемый один раз перед всеми тестами класса."""
        cls.common_resource = create_expensive_resource()
    
    @classmethod
    def tearDownClass(cls):
        """Метод, вызываемый один раз после всех тестов класса."""
        cls.common_resource.cleanup()
```

### Общие фикстуры в conftest.py

Для повторного использования фикстур в нескольких тестовых файлах, их можно определить в файле `conftest.py`:

```python
# conftest.py
import pytest
import os
import tempfile
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

@pytest.fixture
def temp_file():
    """Фикстура, создающая временный файл."""
    fd, path = tempfile.mkstemp()
    yield path
    os.close(fd)
    os.unlink(path)

@pytest.fixture
def db_session():
    """Фикстура, создающая сессию базы данных."""
    engine = create_engine("sqlite:///:memory:")
    Session = sessionmaker(bind=engine)
    session = Session()
    
    # Создание схемы базы данных
    Base.metadata.create_all(engine)
    
    yield session
    
    # Очистка
    session.close()
```

## Моки

Моки - это объекты, имитирующие поведение реальных объектов. Они используются для изоляции тестируемого кода от его зависимостей.

### Создание моков с unittest.mock

```python
from unittest.mock import Mock, MagicMock

# Создание простого мока
mock_repository = Mock()

# Настройка возвращаемого значения
mock_repository.get_by_id.return_value = {"id": 1, "name": "John"}

# Использование мока
service = UserService(repository=mock_repository)
user = service.get_user(1)

# Проверка вызовов мока
mock_repository.get_by_id.assert_called_once_with(1)
```

### Патчинг с unittest.mock

```python
from unittest.mock import patch
import datetime

# Патчинг функции
@patch('myapp.utils.get_current_time')
def test_create_user(mock_get_current_time):
    # Настройка мока
    mock_time = datetime.datetime(2023, 1, 1, 12, 0, 0)
    mock_get_current_time.return_value = mock_time
    
    # Тестирование
    user = create_user("John")
    
    # Проверка
    assert user.created_at == mock_time
    mock_get_current_time.assert_called_once()

# Патчинг метода класса
@patch.object(UserRepository, 'save')
def test_user_service_create(mock_save):
    # Настройка мока
    mock_save.return_value = {"id": 1, "name": "John"}
    
    # Тестирование
    service = UserService(repository=UserRepository())
    user = service.create_user("John")
    
    # Проверка
    assert user["id"] == 1
    assert user["name"] == "John"
    mock_save.assert_called_once()

# Патчинг нескольких объектов
@patch('myapp.utils.get_current_time')
@patch('myapp.repositories.UserRepository')
def test_multiple_patches(mock_repository_class, mock_get_current_time):
    # Настройка моков
    mock_time = datetime.datetime(2023, 1, 1, 12, 0, 0)
    mock_get_current_time.return_value = mock_time
    
    mock_repository = mock_repository_class.return_value
    mock_repository.save.return_value = {"id": 1, "name": "John"}
    
    # Тестирование
    service = UserService()
    user = service.create_user("John")
    
    # Проверка
    assert user["id"] == 1
    assert user["name"] == "John"
    assert user["created_at"] == mock_time
    mock_repository.save.assert_called_once()
    mock_get_current_time.assert_called_once()
```

### Патчинг с контекстным менеджером

```python
from unittest.mock import patch

def test_with_context_manager():
    with patch('myapp.utils.get_current_time') as mock_get_current_time:
        # Настройка мока
        mock_time = datetime.datetime(2023, 1, 1, 12, 0, 0)
        mock_get_current_time.return_value = mock_time
        
        # Тестирование
        user = create_user("John")
        
        # Проверка
        assert user.created_at == mock_time
        mock_get_current_time.assert_called_once()
```

### Моки с возвращаемыми значениями и исключениями

```python
from unittest.mock import Mock

# Мок с возвращаемым значением
mock_repository = Mock()
mock_repository.get_by_id.return_value = {"id": 1, "name": "John"}

# Мок, возвращающий разные значения при последовательных вызовах
mock_repository.get_by_id.side_effect = [
    {"id": 1, "name": "John"},
    {"id": 2, "name": "Jane"},
    {"id": 3, "name": "Bob"}
]

# Мок, вызывающий исключение
mock_repository.get_by_id.side_effect = ValueError("User not found")

# Мок с функцией в качестве side_effect
def get_user_by_id(user_id):
    if user_id == 1:
        return {"id": 1, "name": "John"}
    else:
        raise ValueError(f"User with id {user_id} not found")

mock_repository.get_by_id.side_effect = get_user_by_id
```

### Проверка вызовов моков

```python
from unittest.mock import Mock, call

mock_repository = Mock()

# Вызов мока
service = UserService(repository=mock_repository)
service.get_user(1)
service.get_user(2)
service.get_user(3)

# Проверка, что мок был вызван
assert mock_repository.get_by_id.called

# Проверка количества вызовов
assert mock_repository.get_by_id.call_count == 3

# Проверка, что мок был вызван с определенными аргументами
mock_repository.get_by_id.assert_called_with(3)  # Последний вызов
mock_repository.get_by_id.assert_called_once_with(1)  # Ошибка, так как было несколько вызовов

# Проверка всех вызовов
mock_repository.get_by_id.assert_has_calls([
    call(1),
    call(2),
    call(3)
])

# Проверка, что не было других вызовов
mock_repository.get_by_id.assert_has_calls([
    call(1),
    call(2),
    call(3)
], any_order=False)
```

### Моки с pytest-mock

```python
def test_with_pytest_mock(mocker):
    # Патчинг функции
    mock_get_current_time = mocker.patch('myapp.utils.get_current_time')
    mock_time = datetime.datetime(2023, 1, 1, 12, 0, 0)
    mock_get_current_time.return_value = mock_time
    
    # Патчинг метода класса
    mock_save = mocker.patch.object(UserRepository, 'save')
    mock_save.return_value = {"id": 1, "name": "John"}
    
    # Создание мока
    mock_repository = mocker.Mock()
    mock_repository.get_by_id.return_value = {"id": 1, "name": "John"}
    
    # Шпион (spy) для существующего объекта
    spy = mocker.spy(service, 'get_user')
    service.get_user(1)
    assert spy.call_count == 1
    assert spy.call_args == call(1)
```

## Лучшие практики

### 1. Используйте фикстуры для повторяющейся настройки

```python
# Неправильно: повторение кода настройки
def test_create_user():
    # Настройка
    db_session = create_test_session()
    repository = UserRepository(db_session)
    service = UserService(repository)
    
    # Тест
    user = service.create_user("John", "john@example.com")
    assert user.name == "John"
    
    # Очистка
    db_session.close()

def test_update_user():
    # Настройка (повторение)
    db_session = create_test_session()
    repository = UserRepository(db_session)
    service = UserService(repository)
    
    # Тест
    user = service.create_user("John", "john@example.com")
    updated_user = service.update_user(user.id, name="Jane")
    assert updated_user.name == "Jane"
    
    # Очистка
    db_session.close()

# Правильно: использование фикстуры
@pytest.fixture
def user_service():
    # Настройка
    db_session = create_test_session()
    repository = UserRepository(db_session)
    service = UserService(repository)
    
    yield service
    
    # Очистка
    db_session.close()

def test_create_user(user_service):
    user = user_service.create_user("John", "john@example.com")
    assert user.name == "John"

def test_update_user(user_service):
    user = user_service.create_user("John", "john@example.com")
    updated_user = user_service.update_user(user.id, name="Jane")
    assert updated_user.name == "Jane"
```

### 2. Используйте моки для изоляции тестов

```python
# Неправильно: зависимость от внешней системы
def test_send_email():
    email_service = EmailService()
    result = email_service.send("test@example.com", "Test Subject", "Test Body")
    assert result.success is True

# Правильно: использование мока
def test_send_email(mocker):
    # Мок для SMTP-клиента
    mock_smtp = mocker.patch('smtplib.SMTP')
    
    # Настройка мока
    mock_smtp_instance = mock_smtp.return_value
    
    # Тестирование
    email_service = EmailService()
    result = email_service.send("test@example.com", "Test Subject", "Test Body")
    
    # Проверка
    assert result.success is True
    mock_smtp.assert_called_once_with('smtp.example.com', 587)
    mock_smtp_instance.starttls.assert_called_once()
    mock_smtp_instance.login.assert_called_once()
    mock_smtp_instance.sendmail.assert_called_once()
    mock_smtp_instance.quit.assert_called_once()
```

### 3. Используйте фабрики фикстур

```python
import pytest

@pytest.fixture
def make_user_service():
    """Фабрика фикстур для создания UserService с разными параметрами."""
    def _make_user_service(config=None, repository=None):
        config = config or {}
        repository = repository or Mock()
        return UserService(config=config, repository=repository)
    return _make_user_service

def test_user_service_with_default_config(make_user_service):
    service = make_user_service()
    assert service.config == {}

def test_user_service_with_custom_config(make_user_service):
    config = {"timeout": 30, "retry_count": 3}
    service = make_user_service(config=config)
    assert service.config == config

def test_user_service_with_mock_repository(make_user_service):
    mock_repository = Mock()
    mock_repository.get_by_id.return_value = {"id": 1, "name": "John"}
    
    service = make_user_service(repository=mock_repository)
    user = service.get_user(1)
    
    assert user["id"] == 1
    assert user["name"] == "John"
    mock_repository.get_by_id.assert_called_once_with(1)
```

### 4. Используйте автоматические фикстуры

```python
import pytest

@pytest.fixture(autouse=True)
def setup_test_environment():
    """Автоматическая фикстура, которая запускается для каждого теста."""
    # Настройка тестового окружения
    os.environ["TESTING"] = "1"
    os.environ["DATABASE_URL"] = "sqlite:///:memory:"
    
    yield
    
    # Очистка
    os.environ.pop("TESTING")
    os.environ.pop("DATABASE_URL")

def test_database_connection():
    # Тест будет использовать тестовое окружение, настроенное в setup_test_environment
    assert os.environ["TESTING"] == "1"
    assert os.environ["DATABASE_URL"] == "sqlite:///:memory:"
```

### 5. Используйте моки для проверки взаимодействий

```python
from unittest.mock import Mock, call

def test_notification_service():
    # Создание моков
    mock_email_service = Mock()
    mock_sms_service = Mock()
    
    # Настройка сервиса с моками
    notification_service = NotificationService(
        email_service=mock_email_service,
        sms_service=mock_sms_service
    )
    
    # Тестирование
    notification_service.notify_user(
        user_id=1,
        message="Hello",
        channels=["email", "sms"]
    )
    
    # Проверка взаимодействий
    mock_email_service.send.assert_called_once()
    mock_sms_service.send.assert_called_once()
    
    # Проверка порядка вызовов
    mock_manager = Mock()
    mock_manager.attach_mock(mock_email_service, 'email_service')
    mock_manager.attach_mock(mock_sms_service, 'sms_service')
    
    assert mock_manager.mock_calls == [
        call.email_service.send(user_id=1, message="Hello"),
        call.sms_service.send(user_id=1, message="Hello")
    ]
```

## Интеграция с другими правилами

- **Принципы тестирования**: Основные принципы тестирования описаны в @python-testing-principles.mdc
- **Модульное тестирование**: Подробные рекомендации по написанию модульных тестов описаны в @python-unit-testing.mdc
- **Инъекция зависимостей**: Принципы и реализация инъекции зависимостей, которые упрощают тестирование с моками, описаны в @python-dependency-injection.mdc 