---
description: Comprehensive list of technical aspects that must be covered by rules. Apply when creating new rules from scratch, reviewing existing rule sets, or performing gap analysis to ensure complete coverage.
globs:
alwaysApply: false
---

# Cursor Rules Coverage Areas

## 1. Purpose of this Document (P0)

1. MUST use this document as a checklist when creating rule sets from scratch
2. REQUIRED for evaluating completeness of existing rule sets
3. ALWAYS refer to when performing gap analysis of rule coverage
4. MUST consult before finalizing any rule collection

## 2. Required Technical Aspects (P0)

1. **Code Structure**: 
   - Directory organization
   - File naming conventions
   - Import/export patterns
   - Module boundaries
   - Project layout

2. **Architectural Decisions**: 
   - Design principles
   - Architectural patterns
   - Component relationships
   - System boundaries
   - Extension points

3. **Type System**: 
   - Interface definitions
   - Type declarations
   - Type validation
   - Generics usage
   - Type safety requirements

4. **Error Handling**: 
   - Exception hierarchies
   - Error recovery strategies
   - Error propagation patterns
   - Fault tolerance approaches
   - Debug information requirements

5. **Testing**: 
   - Unit testing approaches
   - Integration testing requirements
   - Mock/stub usage patterns
   - Test organization
   - Coverage expectations
   - STRICTLY follow @5-cursor-rules-testing.mdc

6. **Dependency Management**: 
   - Package manager configuration
   - Version constraints
   - Dependency update policies
   - Third-party code integration
   - Dependency injection patterns

7. **Code Style**: 
   - Formatting rules
   - Naming conventions
   - Code organization within files
   - Commenting standards
   - MUST adhere to @4-cursor-rules-format.mdc

8. **Documentation**: 
   - Code comments
   - API documentation
   - README requirements
   - Usage examples
   - Architecture documentation

9. **String Literals**: 
   - Text constants management
   - Internationalization approach
   - Message formatting
   - User-facing text guidelines
   - String concatenation rules

10. **Constants**: 
    - Types of constants
    - Constant placement
    - Naming conventions
    - Usage patterns
    - Configuration constants

11. **Configuration**: 
    - Environment variables
    - Configuration files
    - Secret management
    - Configuration validation
    - Default configurations

12. **Logging**: 
    - Log levels
    - Logging format
    - Contextual information
    - Log rotation
    - Logging granularity

13. **Developer Experience**: 
    - IDE setup
    - Linting configuration
    - Development workflow
    - Tooling recommendations
    - Development environment
    - REQUIRED to implement according to @6-cursor-rules-workflow.mdc

## 3. Additional Technical Aspects (P1)

1. **Framework Patterns**: 
   - Framework-specific idioms
   - Best practices for frameworks
   - Framework version considerations
   - Extension patterns
   - Framework limitations

2. **Integration Points**: 
   - API design principles
   - External service connections
   - Database interaction patterns
   - Authentication integration
   - System boundaries

## 4. Specialized Technical Aspects (P2)

1. **Performance**: 
   - Resource management
   - Optimization techniques
   - Performance measurement
   - Benchmarking approaches
   - Scalability considerations

2. **Security**: 
   - Input validation
   - Authentication patterns
   - Authorization models
   - Data protection
   - Security testing

3. **Accessibility**:
   - Inclusive design principles
   - Accessibility standards compliance
   - Assistive technology support
   - Keyboard navigation
   - Screen reader compatibility

## 5. Infrastructure Aspects (P3)

1. **DevOps/CI/CD**:
   - Build pipeline configuration
   - Deployment strategies
   - Infrastructure as code
   - Container management
   - Environment configuration

2. **Monitoring**:
   - Observability approach
   - Health checks
   - Metrics collection
   - Alert configuration
   - Tracing implementation

3. **Future-proofing**:
   - Technology evolution
   - Deprecation policies
   - Migration strategies
   - Backwards compatibility
   - Technical debt management 